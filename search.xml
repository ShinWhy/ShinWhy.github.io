<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>德语学习</title>
      <link href="/2023/08/02/German/"/>
      <url>/2023/08/02/German/</url>
      
        <content type="html"><![CDATA[<h1 id="字母"><a href="#字母" class="headerlink" title="字母"></a>字母</h1><p>啊 A a<br>杯 B b<br>C c [tse:]<br>D d [de:]<br>E e [e:]<br>F f<br>G g [ge:]<br>H h [ha:]<br>I i [i:]<br>J j<br>K a [Ka:]<br>L l<br>M m<br>N n<br>O o<br>P p [pe:]<br>Q q [ku:]<br>R r<br>S s<br>T t<br>U u<br>V v<br>W w<br>X x<br>Y y<br>Z z</p><h2 id="元音字母"><a href="#元音字母" class="headerlink" title="元音字母"></a>元音字母</h2><table><thead><tr><th align="center">a</th><th align="center">e</th><th align="center">i</th><th align="center">o</th><th align="center">u</th></tr></thead><tbody><tr><td align="center">啊</td><td align="center">A</td><td align="center">衣</td><td align="center">欧</td><td align="center">乌</td></tr></tbody></table><p>啥时候读</p><ol><li>单音节词以元音字母结尾时</li><li>元音字母之后有不发音的字母”h”作为延长音符号时，如ah,eh,ih,oh,uh,geht,Kuh等等</li><li>元音字母重叠时，即aa,ee,ie,oo, 如：Aal, Maat, Tee, See, die, Sie, Boot等等<br>德语单词里没有ii重叠的现象，以<strong>ie</strong>的形式代替。也没有<strong>uu</strong>重叠的现象，所以uh读u的长音，如Uhr, Uhren等</li><li>元音字母之后只有一个辅音字母时，该元音通常也读长音，如 gut, Tat, tun, tut, Kino, Kinos, Politik等</li><li>双音节或多音节单词中以元音字母单独作为一个音节时，如：Oma, Omi, Opa, Opi, Alu, Ameisen等</li></ol><p>hhhhwwww<br><img src="/images/medicine-melancholy-touhou-lying-down-red-eyes-doll-anime-53262.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> German </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> German </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>口语表达</title>
      <link href="/2023/07/19/SE2_research/"/>
      <url>/2023/07/19/SE2_research/</url>
      
        <content type="html"><![CDATA[<ol><li>Introduction<br>microservices: 每个服务在其进程中运行并使用轻量级机制进行通信，不同服务之间的通信需要时间<br>Mainstream approaches to performance assessment：passive monitoring of the response time and resource utilization.</li></ol><p>This paper: enabling <strong>automated decision gates</strong> in performance testing of microservices that allow requirements traceability.</p><p>Methodology: integrating load testing and Bayesian inference</p><ol><li>目标操作的设计时分析：multiple user categories<br>analysis of the operational setting</li><li>通过负载测试和推断进行性能模型学习<br>指定一些关于SUT的先验知识，自动执行多个负载测试，并逐步学习系统行为。在此过程中，逐步完善DTMC模型，最后得到一个CTMC模型（第三阶段的输入）</li><li>验证要求并计算配置得分(PRISM)<br>verification<blockquote><p>什么是Discrete Time Markov Chain(DTMC): 状态空间中经过<strong>从一个状态到另一个状态的转换的随机过程</strong>。 该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关</p></blockquote></li></ol><blockquote><p>CTMC: 连续时间的马尔科夫链，其中状态转移发生的速率是随机的，并且每个状态转移的速率可以用指数分布来描述。CTMC模型可以用于描述系统中不同组件之间的交互，并且可以使用概率模型检查器对其进行形式化验证。</p></blockquote><p>key contributions</p><ol><li><p>一种新颖的方法论，通过<strong>自动化负载测试、贝叶斯推理和概率模型检查</strong>，在不同部署方案下对微服务系统进行模型学习和验证。</p></li><li><p>在代表性微服务系统基准测试中评估我们的方法论，指出其优点、成本和有效性威胁。</p></li></ol><blockquote><p>steady-state operator S: 停留在特定状态集的概率<br>transient operator P: 发生特定路径的概率</p></blockquote><blockquote><p>sock shop 是本论文要测试的系统</p></blockquote><p>workload intensity:  the number of (active) concurrent users in the SUT.<br>usage profile:  different groups of users</p><p>matrix C &#x3D; (cij) defining the transition counts for each pair of services (i, j).<br>pij: As an example, the transition probability p3,7 (i.e., getCatalogue → getItem) is equal to P(getCatalogue → getItem | buyer) · P(buyer)</p><p>Inference process<br>Termination condition</p><h1 id="Locust"><a href="#Locust" class="headerlink" title="Locust"></a>Locust</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h2 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h2><p>-P PORT被测系统的端口号<br>-f LOCUSTFILE 脚本文件<br>。。。</p><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><h3 id="常用脚本增强技术"><a href="#常用脚本增强技术" class="headerlink" title="常用脚本增强技术"></a>常用脚本增强技术</h3><ol><li>关联：解决请求之间的依赖关系，将脚本中某些写死的数据，变成来自服务器的动态的每次不一样的数据<br>先存：通过一定的手段将服务器返回的数据进行捕获并且保存<br>后用：在需要关联的地方，调用保存的数据<br>正则表达式&#x2F;jsonpath&#x2F;lxml<br>参数化：<br>断点（检查点）<br>思考时间(等待时间)<br>事务(task)<br>集合点</li></ol>]]></content>
      
      
      <categories>
          
          <category> POLIMI </category>
          
          <category> SE2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> STUDY </tag>
            
            <tag> SE2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/07/11/leetcode(%E6%95%B0%E7%BB%84)/"/>
      <url>/2023/07/11/leetcode(%E6%95%B0%E7%BB%84)/</url>
      
        <content type="html"><![CDATA[<h1 id="1920-Build-Array-from-Permutation"><a href="#1920-Build-Array-from-Permutation" class="headerlink" title="1920. Build Array from Permutation"></a>1920. Build Array from Permutation</h1><blockquote><blockquote><blockquote><blockquote></blockquote><p>vector相关的一些成员：<a href="https://cplusplus.com/reference/vector/vector/">https://cplusplus.com/reference/vector/vector/</a></p></blockquote></blockquote></blockquote><ol><li>Capacity<br>size() 返回数组的长度<br>max_size() 返回最大程度<br>resize() 改变长度</li><li>Modifiers<br>push_back(): 在末尾增加元素<br>pop_back(): 删除最后一个元素<br>reverse(): 翻转整个数组</li><li>构造函数</li></ol><ul><li>vector<int> first;</li><li>vector<int> second(4,100) &#x2F;&#x2F;four ints with value 100</li><li>vector<int> third(second.begin(), second.end());&#x2F;&#x2F;iterating through the second</li><li>vector<int> fourth(third); &#x2F;&#x2F;a copy of the third</li><li>int ans[]&#x3D;new int[nums.length];</li></ul><ol start="4"><li>Iterators<br>begin()<br>end()<blockquote><blockquote><blockquote><blockquote></blockquote><p>这道题可以新建一个数组存放新数据，也可以原地修改(类似高低位的思想)<br>题目中提到<code>nums[]</code>的元素的范围是0到999，所以我们可以将<code>nums[nums[i]]</code>中的元素取模再乘以1000加在<code>nums[i]</code>上。这时数组里保存的元素除以1000得到的除数就是我们想到的答案，余数是原值。</p></blockquote></blockquote></blockquote></li></ol><h1 id="1929-Concatenation-of-Array"><a href="#1929-Concatenation-of-Array" class="headerlink" title="1929. Concatenation of Array"></a>1929. Concatenation of Array</h1><p>要注意不要忘了<code>*</code></p><h1 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</span><br><span class="line"></span><br><span class="line">同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</span><br><span class="line">具体地，我们这样描述该算法，对于长度为 n 的排列 a：</span><br><span class="line"></span><br><span class="line">首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]&lt;a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。</span><br><span class="line"></span><br><span class="line">如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 jjj 满足 a[i]&lt;a[j]。这样「较大数」即为 a[j]。</span><br><span class="line"></span><br><span class="line">交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序</span><br></pre></td></tr></table></figure><p><strong>现在的问题是没注意到【3，2，1】的情况</strong></p><h1 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array"></a>34. Find First and Last Position of Element in Sorted Array</h1><p>要求时间复杂度是O(logn), 用二分查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0, right = ...;</span><br><span class="line"></span><br><span class="line">    while(...) &#123;</span><br><span class="line">        int mid = (right + left) / 2;</span><br><span class="line">        if (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组(Array) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ILP</title>
      <link href="/2023/07/11/FOR_ILP/"/>
      <url>/2023/07/11/FOR_ILP/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-Branch-and-bound-method"><a href="#5-1-Branch-and-bound-method" class="headerlink" title="5.1 Branch-and-bound method"></a>5.1 Branch-and-bound method</h1><p>把feasible region X分成X1和X2两个subregion<br>Branching Tree</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> FOR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> FOR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习简记</title>
      <link href="/2023/06/30/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/06/30/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;Hello, 世界&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$ go build helloworld.go</code><br>在win下生成exe可执行文件</p><p>package：类似于其它语言里的库或模块，一个package由多个.go组成，每个文件都要写package XXX</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Daily Review Plan</title>
      <link href="/2023/06/26/%E6%AF%8F%E6%97%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2023/06/26/%E6%AF%8F%E6%97%A5%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>TCS：<br>DB2：13号前把所有的例题都看完<br>CI：<br>ACA：每天三个小时复习大题<br>FOR：8号之前看完所有的例题<br>MIDA<br>CS<br>MIDA2<br>AAPP<br>AN2DL<br>SE2</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go</title>
      <link href="/2023/06/25/Go%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>/2023/06/25/Go%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="1-1-新语言简介"><a href="#1-1-新语言简介" class="headerlink" title="1.1 新语言简介"></a>1.1 新语言简介</h2><ul><li>名称：FWJ<br>弗雷格-维特根斯坦-乔姆斯基</li><li>类型：一门动态类型多范式高级编程语言</li></ul><h2 id="1-2-第一个FWJ程序"><a href="#1-2-第一个FWJ程序" class="headerlink" title="1.2 第一个FWJ程序"></a>1.2 第一个FWJ程序</h2><p>文件: hello.fwj</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure><h2 id="1-3-FWJ解释器"><a href="#1-3-FWJ解释器" class="headerlink" title="1.3 FWJ解释器"></a>1.3 FWJ解释器</h2><ul><li>实现语言：Go</li><li>原生开发：不依赖第三方库</li><li>代码-词法分析器-语法分析器-求值</li></ul><h2 id="1-4-为什么要做一个语言解释器"><a href="#1-4-为什么要做一个语言解释器" class="headerlink" title="1.4 为什么要做一个语言解释器"></a>1.4 为什么要做一个语言解释器</h2><h1 id="词法分析-Lexing"><a href="#词法分析-Lexing" class="headerlink" title="词法分析(Lexing)"></a>词法分析(Lexing)</h1>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ranking Queries</title>
      <link href="/2023/06/15/DB_Ranking%20queries/"/>
      <url>/2023/06/15/DB_Ranking%20queries/</url>
      
        <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><p>Multi-objective optimization<br>• Main approaches:<br>– Ranking (aka top-k) queries<br>• Top k objects according to a given scoring function<br>– Skyline queries<br>• Set of non-dominated objects</p><h1 id="老办法"><a href="#老办法" class="headerlink" title="老办法"></a>老办法</h1><ol><li>Rank aggregation<br>Borda’s(candidate with the lowest penalty) and Condorcet’s proposals(A candidate who defeats every other candidate in pairwise majority rule election)</li></ol><ul><li>Axiomatic approach</li><li>Metric approach<br>Finding a new ranking R whose total distance to the initial rankings R1,…, Rn is minimized</li></ul><h1 id="Ranking-aka-top-k-queries"><a href="#Ranking-aka-top-k-queries" class="headerlink" title="Ranking (aka top-k) queries"></a>Ranking (aka top-k) queries</h1><ul><li>Combining opaque rankings<br>有多个表，求top-k<br>eg. hotel<br><strong>MedRank</strong> is not optimal<br>§ However, it is instance-optimal</li></ul><h2 id="Top-k-join-queries"><a href="#Top-k-join-queries" class="headerlink" title="Top-k join queries"></a>Top-k join queries</h2><p>SELECT E.*<br>FROM EMP E, DEPT D<br>WHERE E.DNO &#x3D; D.DNO<br>ORDER BY E.Salary &#x2F; D.Budget DESC<br>FETCH FIRST 1 ROW ONLY</p><h2 id="Top-k-1-1-join-queries"><a href="#Top-k-1-1-join-queries" class="headerlink" title="Top-k 1-1 join queries"></a>Top-k 1-1 join queries</h2><p>SELECT *<br>FROM EatWell EW, BreadAndWine BW<br>WHERE EW.Name &#x3D; BW.Name<br>ORDER BY EW.Score + BW.Score DESC<br>FETCH FIRST 1 ROW ONLY</p><h3 id="Common-scoring-functions"><a href="#Common-scoring-functions" class="headerlink" title="Common scoring functions"></a>Common scoring functions</h3><ol><li>SUM (AVG): used to weigh preferences equally<br>SUM(o) º SUM(p(o)) &#x3D; p1(o) + p2(o) + … + pm(o)</li><li>WSUM (Weighted sum): to weigh the ranking attributes differently<br>WSUM(o) º WSUM(p(o)) &#x3D; w1<em>p1(o) + w2</em>p2(o) + … + wm*pm(o)</li><li>MIN (Minimum): just considers the worst partial score<br>MIN(o) º MIN(p(o)) &#x3D; min{p1(o),p2(o), …, pm(o)}</li><li>MAX (Maximum): just considers the best partial score<br>MAX(o) º MAX(p(o)) &#x3D; max{p1(o),p2(o), …, pm(o)}</li></ol><h3 id="The-B0-algorithm-using-a-scoring-function-S"><a href="#The-B0-algorithm-using-a-scoring-function-S" class="headerlink" title="The B0 algorithm(using a scoring function S)"></a>The B0 algorithm(using a scoring function S)</h3><p>B0 only works for MAX<br>有m个排好序的list，在每个list上做k次有序访问，把对象和对应的分数存在buffer里，计算buffer里的每个对象的最大分数，返回topk</p><h3 id="Fagin’s-Algorithm-FA"><a href="#Fagin’s-Algorithm-FA" class="headerlink" title="Fagin’s Algorithm (FA)"></a>Fagin’s Algorithm (FA)</h3><p>at least k objects in common, 找到k个以后在目前遇到的object里面挑</p><h3 id="Threshold-Algorithm-TA"><a href="#Threshold-Algorithm-TA" class="headerlink" title="Threshold Algorithm (TA)"></a>Threshold Algorithm (TA)</h3><p>Threshold(把当前行代入Score函数中)<br>给定Score函数，停止直到top-k的score不比threshold差</p><h3 id="The-NRA-algorithm-preliminaries"><a href="#The-NRA-algorithm-preliminaries" class="headerlink" title="The NRA algorithm: preliminaries"></a>The NRA algorithm: preliminaries</h3><p>| id | lbscore | ubscore |</p><table><thead><tr><th align="center">Algorithm</th><th align="center">Scoring function</th><th align="center">Data access</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">B0</td><td align="center">MAX</td><td align="center">sorted</td><td align="center">instance-optimal</td></tr><tr><td align="center">FA</td><td align="center">monotone</td><td align="center">sorted and random</td><td align="center">cost independent of scoring function</td></tr><tr><td align="center">TA</td><td align="center">monotone</td><td align="center">sorted and random</td><td align="center">instance-optimal</td></tr><tr><td align="center">NRA</td><td align="center">monotone</td><td align="center">sorted</td><td align="center">instance-optimal, no exact scores</td></tr></tbody></table><h1 id="Skyline-queries"><a href="#Skyline-queries" class="headerlink" title="Skyline queries"></a>Skyline queries</h1><p>首先根据某些单调函数来排序，然后画线</p><table><thead><tr><th align="center"></th><th align="center">Ranking queries</th><th align="center">Skyline queries</th></tr></thead><tbody><tr><td align="center">Simplicity</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="center">Overall view of interesting results</td><td align="center">No</td><td align="center">Yes</td></tr><tr><td align="center">Control of cardinality</td><td align="center">Yes</td><td align="center">No</td></tr><tr><td align="center">Trade-off among attributes</td><td align="center">Yes</td><td align="center">No</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> DB2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phiscal Databases</title>
      <link href="/2023/06/15/DB_JPA/"/>
      <url>/2023/06/15/DB_JPA/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>Goals: understanding database development in the context of architecture and application development</p><h2 id="有哪些架构"><a href="#有哪些架构" class="headerlink" title="有哪些架构"></a>有哪些架构</h2><ul><li>Two-tier architectures (client-server)</li><li>Three-tier architectures<br>New element: à middle tier(更好地分离client和server)</li><li>Web “pure HTML” 3-tier architectures<br>The client is a standard Web browser(Thin client)</li><li>Rich Internet Applications<br>Enabling technology: client side scripting (with JavaScript) Fat client</li></ul><h2 id="什么是JPA"><a href="#什么是JPA" class="headerlink" title="什么是JPA"></a>什么是JPA</h2><p><strong>Java Persistence API</strong><br>The specification of an interface for mapping relational data to object oriented data in Java<br>在Java中映射<strong>关系数据</strong>到<strong>面向对象数据</strong>的接口规范。</p><ul><li>Java Transaction API (JTA)<br>• An API for managing transactions in Java</li></ul><h3 id="main-concept"><a href="#main-concept" class="headerlink" title="main concept"></a>main concept</h3><ul><li>Entity</li><li>Persistence Unit(like db schema)</li><li>Persistence Context(like db instance)</li><li>Managed entity</li><li>Entity manager</li><li>Client</li></ul><h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1><p>The technique of bridging the gap between the** object model** and the <strong>relational model</strong></p><h2 id="Entity-Constraints"><a href="#Entity-Constraints" class="headerlink" title="Entity Constraints"></a>Entity Constraints</h2><ol><li>The entity class must have a public or protected no-arg constructor(无参构造函数)</li><li>The entity class must not be final(实体类不能被继承，重写或修改)</li><li><strong>No method or persistent instance variables</strong> of the entity class may be final</li><li>If an entity instance is to be passed by value as a detached object, the Serializable interface must be implemented</li></ol><h2 id="Entity-Identification"><a href="#Entity-Identification" class="headerlink" title="Entity Identification"></a>Entity Identification</h2><p>• Simple Primary key &#x3D; persistent field of the bean<br>used to represent its identity<br>• Composite Primary key &#x3D; set of persistent fields<br>used to represent its identity<br>• Remark: with respect to the POJOs, the persistent<br>identity is a new concept. POJOS do not have a<br>durable identity</p><h2 id="Identifier-generation-options"><a href="#Identifier-generation-options" class="headerlink" title="Identifier generation options"></a>Identifier generation options</h2><ul><li>AUTO<br>The provider generates identifiers by using whatever strategy it wants</li><li>TABLE<br>Identifiers are generated according to a generator table</li><li>SEQUENCE<br>If the underlying DB supports sequences, the provider will use this feature for generating IDs</li><li>IDENTITY<br>If the underlying DB supports primary key identity columns, the provider will use this feature for generating IDs</li></ul><h2 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h2><ol><li>All relationships in JPA are unidirectional</li><li>Based on directionality, one entity plays the role of source and one the role of target.</li><li>Cardinality(基数)</li><li>Ownership</li></ol><p>@joincolumn vs mappedBy</p><h2 id="Join-Table"><a href="#Join-Table" class="headerlink" title="Join Table"></a>Join Table</h2><p>Relationship fetch mode<br>Cascading operations<br>Orphan removal</p><h2 id="ManyToOne-annotation-in-Employee-java"><a href="#ManyToOne-annotation-in-Employee-java" class="headerlink" title="@ManyToOne annotation in Employee.java**"></a>@ManyToOne annotation in Employee.java**</h2><p>@Entity<br>public class Employee {<br>@Id private int id;<br>@ManyToOne<br>@JoinColumn(name&#x3D;”dept_fk”)<br>private Department dept;<br>…<br>}</p><h1 id="EM-The-Entity-Manager"><a href="#EM-The-Entity-Manager" class="headerlink" title="EM(The Entity Manager)"></a>EM(The Entity Manager)</h1><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> DB2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生词本(25周)</title>
      <link href="/2023/06/13/words(week25)/"/>
      <url>/2023/06/13/words(week25)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-The-global-space-economy-is-coming-of-age"><a href="#1-The-global-space-economy-is-coming-of-age" class="headerlink" title="1. The global space economy is coming of age"></a>1. The global space economy is coming of age</h1><p>在这个句子中，“coming of age”是一个习语，意思是某事物已经成熟或发展到了一定的阶段。在这个句子中，“coming of age”表示全球太空经济正在迅速发展并变得更加成熟。</p><p>例如：</p><ul><li>After years of hard work, the young artist’s talent finally came of age and he became famous.（经过多年的努力，这位年轻艺术家终于成名了。）</li><li>The internet has come of age as a powerful tool for communication and commerce.（互联网作为一种强大的通信和商业工具已经越来越成熟。）</li></ul><h1 id="2-Italians-divided-over-Berlusconi-legacy"><a href="#2-Italians-divided-over-Berlusconi-legacy" class="headerlink" title="2. Italians divided over Berlusconi legacy"></a>2. Italians divided over Berlusconi legacy</h1><p>在这个句子中，”divide” 的意思是分裂或分开，”legacy” 指的是某人或某事物留下来的遗产、传统或影响。整个句子的意思是：意大利人对贝卢斯科尼的遗产持不同看法。</p><p>在这里，“divided over” 是一个习语，表示人们对某件事情有不同的观点或立场。以下是一些类似用法的例子：</p><ol><li>The country is divided over the issue of gun control. (全国就枪支管制问题存在分歧)</li><li>Our team was divided over whether to accept the offer or not. (我们团队内部因是否接受那份报价而存在争议)</li></ol><h1 id="3-intrinsically"><a href="#3-intrinsically" class="headerlink" title="3. intrinsically"></a>3. intrinsically</h1><p>[英]· &#x2F;ɪnˈtrɪnsɪkli&#x2F;<br>[副词] 本质上；内在地；固有地<br>例句：</p><ol><li>The value of art is intrinsically linked to its cultural context. (艺术的价值与其文化背景密不可分。)</li><li>Happiness cannot be found in material possessions, it must come from within, intrinsically. (幸福不能从物质拥有中获得，它必须来自内心，是内在的。)</li><li>The beauty of nature is intrinsically connected to the health and well-being of our planet. (大自然的美丽与我们星球的健康和福祉息息相关。)<br>词源：<br>intrinsecus（拉丁语），意为“内部的、本质上的”。</li></ol><h1 id="4-fortiori"><a href="#4-fortiori" class="headerlink" title="4. fortiori"></a>4. fortiori</h1><p>[拉丁语]· &#x2F;fɔːtiˈoʊraɪ&#x2F;<br>[adv.] 更加强有力地；更为明显地；更进一步地<br>例句：</p><ol><li>The evidence against him is strong, and fortiori, he should be found guilty. (对他的指控证据很充分，因此他应该被判有罪。)</li><li>If the government cannot even provide basic necessities for its citizens, then fortiori it has failed in its duty to protect them. (如果政府连基本生活必需品都无法提供给公民，那么它在保护公民方面就更是失败了。)</li><li>He was already a skilled musician before attending music school, so fortiori he excelled in his studies there. (他在上音乐学校之前已经是一位熟练的音乐家，因此在那里表现得尤为出色。)<br>词源：<br>来自拉丁语“fortius”，意为“更强大”。</li></ol>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> New word </category>
          
          <category> 2023.6.6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec14</title>
      <link href="/2023/06/12/Lec14/"/>
      <url>/2023/06/12/Lec14/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec15</title>
      <link href="/2023/06/12/Lec15/"/>
      <url>/2023/06/12/Lec15/</url>
      
        <content type="html"><![CDATA[<p>CPU的速度超过了内存的速度，内存无法跟上处理器的速度<br>引进cache</p><p>Q1: Where can a block be placed in the cache?<br>(Block placement)<br>Fully Associative, (2-way) Set Associative, Direct mapped<br>Q2: How is a block found if it is in the cache?<br>(Block identification)<br>Q3: Which block should be replaced on a miss?<br>(Block replacement)<br>Random, LRU, FIFO<br>Q4: What happens on a write?<br>(Write strategy)<br>Write through, Write back<br>no write allocate(直接将数据写入内存), write allocate(写时取回)</p><p><strong>Cache performance：</strong><br>AMAT &#x3D; Average Memory Access Time<br>CPIALUOps does not include memory instructions</p><p>AMAT &#x3D; Hit time + miss rate x miss penalty</p><ol><li>Reduce the miss rate<br>Hardware Prefetching</li><li>Reduce the miss penalty<br>to introduce a second level cache</li><li>Reduce the time to hit in the cache</li></ol><h1 id="1-Memory-Hierarchy-Review"><a href="#1-Memory-Hierarchy-Review" class="headerlink" title="1. Memory Hierarchy Review"></a>1. Memory Hierarchy Review</h1><h1 id="2-MIMD-Architectures"><a href="#2-MIMD-Architectures" class="headerlink" title="2. MIMD Architectures"></a>2. MIMD Architectures</h1><h1 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h1><p>Memory Address Space Model<br>Single logically shared address space: Shared Memory Architectures<br>Multiple and private address spaces: Message Passing Architectures</p><p>Address Space vs. Physical Memory</p><p>Shared Memory &amp; Message Passing</p><p>解决coherency问题：<br>Two classes of protocols:<br>Snooping Protocols(嗅探)<br>Directory-Based Protocols(基于目录)</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期末考试复习心得</title>
      <link href="/2023/06/11/ACA_Review/"/>
      <url>/2023/06/11/ACA_Review/</url>
      
        <content type="html"><![CDATA[<ol><li>怎么找RAW？<br>对于同一个寄存器，先找到W，再往下看，看有没有R，如果下面有新的W，RAW到此为止</li><li>关于VLIW的题，<br>先找到conflicts，</li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec12:Parallel Architectures:SIMD and intro to MIMD</title>
      <link href="/2023/06/09/Lec13/"/>
      <url>/2023/06/09/Lec13/</url>
      
        <content type="html"><![CDATA[<ol><li>SISD<br>Only one instruction stream, only one data stream</li><li>SIMD<br>Same instruction executed by multiple processors using different data streams.<br>每个处理器都有自己的memory, 只有一个控制单元，只有一个代码副本</li><li>MISD<br>A single data stream is fed into multiple processing units.</li><li>MIMD<br>• Multiple Instruction: every processor may be executing a different instruction stream<br>• Multiple Data: every processor may be working with a different data stream</li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec12:ILP Limits and Superscalar Architecture</title>
      <link href="/2023/06/09/Lec12/"/>
      <url>/2023/06/09/Lec12/</url>
      
        <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><ol><li>Review<br>ILP Journey<br>ILP Definition<br>Superscalar Architectures, Static and Dynamic<br>Schedulers</li><li>Limits to ILP<br>Ideal machine<br>Limits<br>Examples of real architectures</li></ol><h1 id="Superscalar-Execution-为什么多个指令不在同一个时钟周期开始执行呢"><a href="#Superscalar-Execution-为什么多个指令不在同一个时钟周期开始执行呢" class="headerlink" title="Superscalar Execution(为什么多个指令不在同一个时钟周期开始执行呢)"></a>Superscalar Execution(为什么多个指令不在同一个时钟周期开始执行呢)</h1><ol><li>在每个时钟周期fetch多条指令</li><li>Decide on data and control dependencies:<br>dynamic scheduling and dynamic branch<br>prediction</li></ol><h1 id="Modern-Supercalar"><a href="#Modern-Supercalar" class="headerlink" title="Modern Supercalar"></a>Modern Supercalar</h1><p>Dynamic scheduling + multiple issue + speculation</p><h1 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h1><ol><li>Window size</li><li>N. of functional units</li><li>N. of busses</li><li>N. of ports for the register file</li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec11:Explicit Register Renaming</title>
      <link href="/2023/06/09/Lec11/"/>
      <url>/2023/06/09/Lec11/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是renaming"><a href="#什么是renaming" class="headerlink" title="什么是renaming"></a>什么是renaming</h1><p>Key insight: Allocate a new physical destination register for every instruction that writes<br>Very similar to a compiler transformation called Static Single Assignment (SSA) form — but in hardware!</p><p>Mechanism? Keep a translation table:<br>ISA register ➔ physical register mapping</p><p>在decode阶段rename寄存器(Mapping)，但不读取寄存器的值<br>function units从统一的寄存器文件中读写数据，包括已经提交的和临时的寄存器<br>Commit仅仅是改变一下Architectural和Phiscal寄存器的映射关系</p><p>Tomasulo提供Implicit Register Renaming(寄存器被重命名为Reservation Station的标签)<br>现在讨论Explicit Register Renaming:<br>用physical register file(这个比寄存器的数量多得多)<br>ISA register &lt;&#x3D;&gt; physical register mapping<br>当寄存器被写好后，从freelist里找一个新的寄存器来代替表的entry，一个指令有一个entry</p><p>有什么好处？<br>可以消除WAR和WAW<br>和Tomasulo一样，允许out-of-order完成</p><h1 id="Stage-of-Scoreboard-Control-With-Explicit-Renaming"><a href="#Stage-of-Scoreboard-Control-With-Explicit-Renaming" class="headerlink" title="Stage of Scoreboard Control With Explicit Renaming"></a>Stage of Scoreboard Control With Explicit Renaming</h1><ol><li>ISSUE<br>解码 + 检查structural hazards + 为结果分配新的physical register<br>指令按program order来issue，没有空闲的physical register就别issue，有structural hazard别issue</li><li>Read operands<br>等到没有hazard, 再读操作数。所有的dependencies(RAW)都在这个阶段解决</li><li>Execution<br>Function unit一收到操作数就开始执行。当结果都准备好，通知scoreboard</li><li>Write result<br>完成执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">不用检测WAR和WAW</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="An-example"><a href="#An-example" class="headerlink" title="An example"></a>An example</h1><ol><li>什么时候需要rename？<br>只有destination register才需要renaming</li><li>放入一次function unit status表，就rename一次destination register</li><li>不用考虑每条指令等待几个周期，只需要一个周期一个周期往下推就行，RAW hazard中，被依赖的指令完成后(第n个周期Write Result)，才可以执行下一条指令(第n+1个周期read operands)</li></ol><h1 id="Register-renaming-vs-ROB"><a href="#Register-renaming-vs-ROB" class="headerlink" title="Register renaming vs. ROB"></a>Register renaming vs. ROB</h1><p>前者指令commit更简单一些，但释放寄存器更为复杂</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec10:Hardware-Based Speculation</title>
      <link href="/2023/06/08/Lec10/"/>
      <url>/2023/06/08/Lec10/</url>
      
        <content type="html"><![CDATA[<h1 id="HW-based-speculation-main-idea"><a href="#HW-based-speculation-main-idea" class="headerlink" title="HW-based speculation main idea"></a>HW-based speculation main idea</h1><ol><li>Dynamic Branch Prediction<br>choose which instruction to execute</li><li>Dynamic Scheduling<br>out-of-order execution but inorder commit </li><li>Speculation<br>execute instructions before control dependences are resolved</li></ol><h2 id="The-key-idea-behind-speculation-is"><a href="#The-key-idea-behind-speculation-is" class="headerlink" title="The key idea behind speculation is"></a>The key idea behind speculation is</h2><ol><li>to <strong>issue and execute instructions dependent on a branch</strong> before the branch outcome is known;</li><li>to allow instructions to <strong>execute out-of-order</strong> but to force them to <strong>commit in-order</strong>;<br>to prevent any irrevocable action (such as updating state or taking an exception) until an instruction commits;</li></ol><h1 id="Reorder-Buffer"><a href="#Reorder-Buffer" class="headerlink" title="Reorder Buffer"></a>Reorder Buffer</h1><ol><li>Re-order buffer(ROB)保存未提交但已完成的寄存器的结果(从completion到commit)<br>指令什么时候提交？1. 完成execution 2. 前面的指令都提交<br>当指令提交后，结果就会从ROB转到register</li><li>Entries(条目)在decode的阶段按程序的顺序分配</li><li>已完成(completed)未提交(uncommited)的值可以被相关指令使用</li><li>load&#x2F;store指令的reordering需要特殊的数据结构</li></ol><h2 id="Speculative-Tomasulo-Algorithm"><a href="#Speculative-Tomasulo-Algorithm" class="headerlink" title="Speculative Tomasulo Algorithm"></a>Speculative Tomasulo Algorithm</h2><ol><li>Issue<br>如果Reservation Station和Reorder Buffer slot都有空，就issue instruction &amp;&amp; send operands &amp;&amp; reorder buffer no. for destination</li><li>Execution<br>当两个操作数都准备好，就开始execution，没准备好，就等CDB(common data bus)，当两个操作数都在 reservation station，执行</li><li>Write Result<br>写到CDB准备好传给等待的FU和ROB</li><li>Commit<br>3种：normal commit, Store commit, Instruction is a branch with incorrect prediction</li></ol><h2 id="Each-entry-in-ROB-contains-four-fields"><a href="#Each-entry-in-ROB-contains-four-fields" class="headerlink" title="Each entry in ROB contains four fields"></a>Each entry in ROB contains four fields</h2><ol><li><strong>Instruction type field</strong> – indicates whether instruction is a branch (no destination<br>result), a store (has memory address destination), or a load&#x2F;ALU (register<br>destination)</li><li><strong>Destination field</strong>: supplies register number (for loads and ALU instructions) or<br>memory address (for stores) where results should be written;</li><li><strong>Value field</strong> (used to hold value of result until instruction commits)</li><li><strong>Ready field</strong>: indicates that instruction has completed execution, value is ready</li></ol><h1 id="An-example"><a href="#An-example" class="headerlink" title="An example"></a>An example</h1>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec9:Exception Handling</title>
      <link href="/2023/06/08/Lec9/"/>
      <url>/2023/06/08/Lec9/</url>
      
        <content type="html"><![CDATA[<h1 id="Classes-of-exceptions"><a href="#Classes-of-exceptions" class="headerlink" title="Classes of exceptions"></a>Classes of exceptions</h1><ol><li>Synchronous vs asynchronous</li><li>User requested vs coerced(被迫)</li><li>User maskable vs user nonmaskable</li><li>Within vs between instructions</li><li>Resume vs terminate</li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec8:Dynamic Scheduling, Tomasulo</title>
      <link href="/2023/06/07/Lec8/"/>
      <url>/2023/06/07/Lec8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Tomasulo-algorithm"><a href="#1-Tomasulo-algorithm" class="headerlink" title="1. Tomasulo algorithm"></a>1. Tomasulo algorithm</h1><p>Reservation Stations(Operand buffers)<br>Each instruction is an entry of a reservation station<br>Its operands are replaced by values or pointers (Register Renaming)-&gt;<strong>避免WAR和WAW</strong></p><h2 id="3-stage-of-the-Tomasulo-Algorithm"><a href="#3-stage-of-the-Tomasulo-Algorithm" class="headerlink" title="3-stage of the Tomasulo Algorithm:"></a>3-stage of the Tomasulo Algorithm:</h2><p>ISSUE<br>EXECUTION<br>WRITE</p><p><strong>Reservation Station Components</strong></p><ul><li>Tag identifying the RS</li><li>OP &#x3D; the operation to perform on the component.</li><li>Vj, Vk &#x3D; Value of the source operands</li><li>Qj,Qk &#x3D; Pointers to RS that produce Vj,Vk<br>Zero value &#x3D; Source op. is already available in Vj or Vk</li><li>Busy &#x3D; Indicates RS Busy<br>Note: Only one of V-field or Q-field is valid for each operand<br><strong>其他component</strong></li><li>RF and the Store buffer have a Value (V) and a Pointer (Q) field.<br>Pointer (Q) field corresponds to number of reservation station producing the<br>result to be stored in RF or store buffer<br>If zero  no active instructions producing the result<br>(RF or store buffer content is the correct value).</li></ul><h1 id="2-Comparison-between-Scoreboard-and-Tomasulo"><a href="#2-Comparison-between-Scoreboard-and-Tomasulo" class="headerlink" title="2. Comparison between Scoreboard and Tomasulo"></a>2. Comparison between Scoreboard and Tomasulo</h1><p>• Control &amp; buffers distributed with Function Units (FU) vs.<br>centralized in scoreboard;<br>• FU buffers called “reservation stations”; have pending operands<br>• Registers in instructions replaced by values or pointers to<br>reservation stations(RS); called register renaming ;<br>• avoids WAR, WAW hazards<br>• More reservation stations than registers, so can do optimizations compilers can’t<br>• Results to FU from RS, not through registers, over Common Data<br>Bus that broadcasts results to all FUs<br>• Load and Stores treated as FUs with RSs as well<br>• Integer instructions can go past branches, allowing<br>FP ops beyond basic block in FP queue</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生词本(24周)</title>
      <link href="/2023/06/06/words(week24)/"/>
      <url>/2023/06/06/words(week24)/</url>
      
        <content type="html"><![CDATA[<h1 id="Initiation-interval"><a href="#Initiation-interval" class="headerlink" title="Initiation interval"></a>Initiation interval</h1><p>在这个句子中，“interval”是一个名词，表示两个事件或时间之间的间隔。在“Initiation interval”的语境下，它指的是某个过程中开始和结束之间的时间段。</p><p>这个句子的意思是，在某个过程中，有一个特定的时间段用来启动该过程。</p><p>在英语中，“interval”还可以用于描述音乐、体育比赛等方面。例如：</p><ul><li>The orchestra took a short interval after the first movement. (管弦乐队在第一部分后休息了一会儿。)</li><li>There will be a 15-minute interval between the two halves of the football match. (足球比赛两半场之间将有15分钟的休息时间。)</li></ul><h1 id="pending"><a href="#pending" class="headerlink" title="pending"></a>pending</h1><p>在这个句子中，单词”pending”是一个形容词，用来描述指令的状态。它意味着有一些指令已经被下达但还没有完成或者等待执行。</p><p>整个句子的意思是：如果没有未决的指示，就会将该寄存器写入空白。</p><p>在这个句子中，并没有使用到任何习语。以下是几个例子：</p><ol><li>My pending workload is making me stressed out. (我的待处理工作量让我感到很压力)</li><li>The court case has been pending for months now. (这起法庭案件已经悬而未决数月了)</li></ol><h1 id="plain-old"><a href="#plain-old" class="headerlink" title="plain old"></a>plain old</h1><p>Plain Old”也可以用作习惯用语来表示“非常普通、平凡”的含义。例如，“plain old car”就表示“非常普通的汽车”</p><h1 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h1><p>[英]· &#x2F;ˌænəʊˈteɪʃən&#x2F; 或 &#x2F;ˌanəʊˈteɪʃ(ə)n&#x2F;<br>[n.] 注释；评注；批注<br>[v.] 给…作注解；加注释于…<br>例句：</p><ol><li>The book contains annotations by the author. (这本书包含了作者的注释。)</li><li>She spent hours annotating her research paper. (她花了几个小时给她的研究论文做标记。)</li><li>The software allows users to annotate PDF documents with comments and highlights. (该软件允许用户使用评论和高亮显示来对PDF文件进行标记。)</li></ol><p>词源：来自拉丁语“annotatio”，意为“解释，说明”。</p><h1 id="specification"><a href="#specification" class="headerlink" title="specification"></a>specification</h1><p>[英]· &#x2F;ˌspesɪfɪˈkeɪʃ(ə)n&#x2F;  美· &#x2F;ˌspɛsəfɪˈkeʃən&#x2F;<br>[n.] 规格；规范；说明书<br>例句：</p><ol><li>The product specification should be clearly stated in the contract. (产品规格应在合同中明确说明。)</li><li>The software developer needs to follow the project specification closely. (软件开发人员需要密切遵循项目规范。)</li><li>This job requires someone who can read and interpret technical specifications accurately. (这份工作需要一个能够准确阅读和解释技术规范的人。)<br>词源：来自拉丁语“specificatio”，意为“具体化，详述”。</li></ol><h1 id="vice-versa"><a href="#vice-versa" class="headerlink" title="vice versa"></a>vice versa</h1><p>反之亦然</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> New word </category>
          
          <category> 2023.6.6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec7:Dynamic Scheduling, Scoreboard</title>
      <link href="/2023/06/05/Lec7/"/>
      <url>/2023/06/05/Lec7/</url>
      
        <content type="html"><![CDATA[<h1 id="Dynamic-Scheduling"><a href="#Dynamic-Scheduling" class="headerlink" title="Dynamic Scheduling"></a>Dynamic Scheduling</h1><p>Enables out-of-order execution and completion (commit)<br><strong>一个表结构</strong><br>A Data Structure for Correct Issues<br>Keeps track of the status of Functional Units</p><h1 id="Scoreboard-Operation"><a href="#Scoreboard-Operation" class="headerlink" title="Scoreboard Operation"></a>Scoreboard Operation</h1><p>New pipeline</p><table><thead><tr><th align="center">ID</th><th align="center">ID</th><th align="center">EX</th><th align="center">WB</th></tr></thead><tbody><tr><td align="center">Issue</td><td align="center">Read regs</td><td align="center">Execution</td><td align="center">Write</td></tr></tbody></table><h2 id="Four-Stages-of-Scoreboard-Control"><a href="#Four-Stages-of-Scoreboard-Control" class="headerlink" title="Four Stages of Scoreboard Control"></a>Four Stages of Scoreboard Control</h2><ol><li>Issue(in-order)<br>structural harzard &amp;&amp; WAW(has the same destination)</li><li>Read Operands(out of order)<br>Wait until no data hazards(RAW hazard)</li><li>Execution<br>latency, Initiation interval </li><li>Write Result<br>Finish execution<br>Once the scoreboard is aware that the functional unit has completed execution, the scoreboard checks for <em>WAR hazards</em>.<br>If none, it writes results. If WAR, then it stalls the instruction.</li></ol><h2 id="Scoreboard-structure-three-parts"><a href="#Scoreboard-structure-three-parts" class="headerlink" title="Scoreboard structure: three parts"></a>Scoreboard structure: three parts</h2><ol><li><p>Instruction status</p></li><li><p>Functional Unit status<br>Indicates the state of the functional unit (FU):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Busy – Indicates whether the unit is busy or not</span><br><span class="line">Op - The operation to perform in the unit (+,-, etc.)</span><br><span class="line">Fi - Destination register</span><br><span class="line">Fj, Fk – Source register numbers</span><br><span class="line">Qj, Qk – Functional units producing source registers</span><br><span class="line">Rj, Rk – Flags indicating when Fj, Fk are ready</span><br></pre></td></tr></table></figure><p>Rj表示Fj(Fk)准备好了没有，Fj(Fk)表示源寄存器的数据准备好了没有<br>Fi是目标寄存器</p></li><li><p>Register result status<br>Indicates <strong>which functional unit</strong> will write each register.<br>Blank if no pending instructions will write that register.z</p></li></ol><h2 id="Execution-Process"><a href="#Execution-Process" class="headerlink" title="Execution Process"></a>Execution Process</h2><ol><li>Issue<br>• Functional unit is free (<strong>structural</strong>)<br>• Active instructions do not have same Rd (<strong>WAW</strong>)</li><li>Read Operands<br>• Checks availability of source operands<br>• Resolves <strong>RAW</strong> hazards dynamically (out-of-order execution)</li><li>Execution<br>• Functional unit begins execution when operands arrive<br>• Notifies the scoreboard when it has completed execution</li><li>Write result<br>• Scoreboard checks <strong>WAR</strong> hazards<br>• Stalls the completing instruction if necessary</li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI各单元简记</title>
      <link href="/2023/06/05/CI/"/>
      <url>/2023/06/05/CI/</url>
      
        <content type="html"><![CDATA[<h1 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h1><p><strong>A. HW Infrastructures:</strong><br>• System-level: Computing Infrastructures and Data Center<br>Architectures, Rack&#x2F;Structure;<br>• Node-level: Server (computation, HW accelerators), Storage<br>(Type, technology), Networking (architecture and technology);<br>• Building-level: Cooling systems, power supply, failure recovery<br><strong>B. SW Infrastructures:</strong><br>• Virtualization: Process&#x2F;System VM, Virtualization Mechanisms<br>(Hypervisor, Para&#x2F;Full virtualization)<br>• Computing Architectures: Cloud Computing (types,<br>characteristics), Edge&#x2F;Fog Computing, X-as-a service<br>• Machine and deep learning-as-a-service<br><strong>C. Methods:</strong><br>• Reliability and availability of datacenters (definition,<br>fundamental laws, RBDs)<br>• Disk performance (Type, Performance, RAID)<br>• Scalability and performance of datacenters (definitions,<br>fundamental laws, queuing network theory)</p><p>IoT<br>Embedded PCs&#x2F;Devices<br>PCs<br>Edge&#x2F;Fog Computing Systems<br>Embedded PCs</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>Quality Evaluation techniques: </p><ol><li>Measurement-based</li></ol><ul><li>Direct measurement</li><li>Benchmarking</li><li>Prototype</li></ul><ol start="2"><li>Model-based</li></ol><ul><li>Analytical and numerical</li><li>Simulation</li><li>Hybrid techniques<br>eg. Queueing Networks<br>• Arrival: average arrival rate \lambda  (req&#x2F;s)<br>• Service: the time a job spends being served,  average duration, maximum service rate<br>• Queue: Service discipline&#x2F;queuing policy: FCFS, LCFS, RSS, PRI<br>• Population: Service discipline&#x2F;queuing policy<br>• Routing: Probabilistic, Round robin, Join the shortest queue</li></ul><p>If we observed such an abstract system we might measure the following<br>quantities:<br>§ T, the length of <strong>time</strong> we observe the system<br>§ A, the number of <strong>request arrivals</strong> we observe<br>§ C, the number of <strong>request completions</strong> we observe<br>§ B, the total amount of time during which the system is <strong>busy</strong>(B&lt;&#x3D;T&gt;)<br>§ N, the <strong>average number of jobs</strong> in the system </p><p>§ λ &#x3D; A&#x2F;T , the arrival rate 到达率<br>§ X &#x3D; C &#x2F;T , the throughput or completion rate 完成率或吞吐量<br>§ U &#x3D; B&#x2F;T, the utilisation 利用率<br>§ S &#x3D; B&#x2F;C, the mean service time per completed job 每个job平均使用资源k的时间</p><p><strong>utilization law:</strong><br>Uk &#x3D; XkSk &#x3D; B&#x2F;T &#x3D; C&#x2F;T * B&#x2F;C 完成率<em>平均使用资源k的时间<br><strong>Little’s law:</strong><br>N &#x3D; XR  吞吐量</em>平均居留时间&#x3D;系统中的请求数<br>(N &#x3D; average number of requests in the system(在系统中同时存在的请求数)<br>If the system throughput is X requests&#x2F;sec, and each request remains in the system on average for R seconds)</p><p><strong>Response Time Law</strong><br>R &#x3D; N&#x2F;X - Z residence time - thinking time</p><p>T: 我们观察的总时间<br>Ak: 对于资源k，到达的请求的数量<br>Ck: 对于资源k，完成的请求的数量<br>Bk: 资源k忙的时间<br>Nk：资源k平均完成的工作数量<br><strong>N &#x3D; XR</strong><br>level1：N: busy time; X: average service time; R: rate of service<br>level2(考虑queue): N: 等待或正在享受服务的用户数量 X:系统的吞吐量 R&#x3D;N&#x2F;X:每个用户花费的时间<br>level3(考虑subsystem): N:在<strong>子系统</strong>中的用户数量  X: <strong>子系统</strong>中每个请求花费的时间 R: <strong>子系统</strong>的throughput<br>level4(考虑total system):</p><p>关于little’s law的一些理解：</p><ol><li>如果提到系统中有几个活跃的用户，那么N就等于几</li><li>告诉 U 和 S(service time)，怎么求X? U&#x3D;B&#x2F;T, X&#x3D;C&#x2F;T, S&#x3D;B&#x2F;C 所以S&#x3D;U&#x2F;X</li><li>题设告知think time, response time, residence time(N&#x2F;X)，N&#x3D;N(think)+N(response)</li><li>整个系统的吞吐量等于各个子系统的吞吐量</li><li>告知每个子系统的利用率(U)和demand(D), 则可求吞吐量(X):<br>这是用了Utilization Law(U&#x3D;XS): S是service time, 在有些题目里，表示成demand</li></ol><p>Xk &#x3D; Vk * X<br>Vk &#x3D; Ck &#x2F; C</p><h2 id="DataWareHouse"><a href="#DataWareHouse" class="headerlink" title="DataWareHouse"></a>DataWareHouse</h2><p>warehouse-scale computers (WSCs):</p><p>Multiple data centers：<br>Hierarchical approach: </p><ul><li>Geographic Areas and Regions</li><li>Availability Zones</li></ul><p>Architectural Overview of A Warehouse-scale Computer</p><ul><li>SERVERS: the main processing equipment</li><li>STORAGE: how and where to store the information</li><li>NETWORKING: providing internal and external connections</li><li>BUILDING AND INFRASTRUCTURE: power delivery, cooling, and building infrastructure</li></ul><h2 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h2><p>Stages of enterprise infrastructures</p><ol><li>Monolithic app(单体式应用程序)</li></ol><ul><li>Minimal network demands</li><li>Proprietary protocols</li></ul><ol start="2"><li>Client server</li></ol><ul><li>High network demands inside the enterprise</li><li>Applications walled within the enterprise</li><li>TCP&#x2F;IP + Proprietary protocols</li></ul><ol start="3"><li>Web applications</li></ol><ul><li>Ubiquitous TCP&#x2F;IP</li><li>Access from anywhere</li><li>Servers are broken into multiple units</li></ul><ol start="4"><li>Microservices</li></ol><ul><li>Infrastructure moved to cloud providers</li><li>Servers broken into microservices</li><li>Increase of server-to-server traffic</li></ul><p>Classes of DCN<br>DCNs can be classified into three main categories:</p><ol><li>Switch-centric architectures<br>Uses switches to perform packet forwarding<br><strong>Three-Tier (or layer) “Classical” Network</strong>: Core, Aggregation(EOR), Access(TOR)<br><strong>Leaf-Spine architectures</strong></li><li>Server-centric architecture<br>Uses servers with multiple Network Interface Cards (NICs) to act as switches in addition to performing other computational functions</li></ol><p>Two stage interconnections<br>Leaf: ToR switch<br>Spine: dedicated switches (aggregation switches)<br>In practice: servers have two interfaces connected to two ToR switches</p><p>扩展到三层：Pod-based model, aka the Fat Tree<br>to provide fault-tolerance<br>3. Hybrid architectures<br>Combine switches and servers for packet forwarding</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> CI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/04/weekly2/"/>
      <url>/2023/06/04/weekly2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LP</title>
      <link href="/2023/06/01/FOR_LP/"/>
      <url>/2023/06/01/FOR_LP/</url>
      
        <content type="html"><![CDATA[<h1 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h1><p>min f(x)<br>s.t. x属于X<br>General form:<br>min z &#x3D; c1x1 + c2c2 +…+cnxn<br>s.t.<br>Matrix notation<br>min z &#x3D; [c1 … cn][]</p><p><strong>Standard form</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min z = cTx</span><br><span class="line">s.t. Ax = b</span><br><span class="line">     x&gt;=0   (only equality constraints and all nonnegative variables)</span><br></pre></td></tr></table></figure><p>方法：把小于0的x变成(xi-xj), 添加slack variable和surplus variable, 改变目标函数的符号</p><h1 id="Basic-feasible-solutions-and-vertices-of-polyhedra"><a href="#Basic-feasible-solutions-and-vertices-of-polyhedra" class="headerlink" title="Basic feasible solutions and vertices of polyhedra"></a>Basic feasible solutions and vertices of polyhedra</h1><p>Ax&#x3D;b<br>A&#x3D;&gt;m<em>n<br>rank&#x3D;m(A is full of rank)<br>m &#x3D; n unique solution<br>m &lt; n 无穷个solution<br>A&#x3D;[B|N]<br>B: a basis of such a matrix A——————m</em>m<br>N: m*(n-m)</p><p>XT &#x3D; [XBT|XNT]<br>A basic solution is a solution obtained by setting <strong>xN&#x3D;0</strong>，<br>A basic solution with <strong>XB&gt;&#x3D;0</strong> is a <strong>basic feasible solution</strong>.<br>The variable in XB——-basic variables, non basic variables</p><h1 id="单纯形算法（simplex-method）"><a href="#单纯形算法（simplex-method）" class="headerlink" title="单纯形算法（simplex method）"></a>单纯形算法（simplex method）</h1><p>算法的基本思想是通过在多维空间中移动一个特定形状的多面体，寻找目标函数取得最优值的顶点<br>上课时的思路：<br>什么是单纯形法：</p><ol><li>在<strong>不增加目标函数值</strong>的前提下检测一系列的基本可行解，直到找到最优解或者发现线性规划是无界的<br>在每次循环中，从一个基本可行解移至另一个基本可行解。</li><li>那我们该怎么做呢？</li></ol><ul><li>先找到一个初始的vertex(基本可行解)</li><li>确定当前的vertex是不是最优解</li><li>如果不是，就从当前的vertex一道一个更好的相邻的vertex(或者说名这个LP是无界的)</li></ul><ol start="3"><li>分别看这些步骤</li></ol><ul><li>初始的vertex很好看出来</li><li>怎么确定当前的vertex是不是最优解？————引出reduced cost!!!<br>通过计算cTx，可以看出cost是由一个固定的值和一个变化的值组成的，其中变化的那个部分就是reduced cost，reduced cost是由于non basic 变量引起的(NNBBN)。</li><li>如果cN&gt;0, 那么xB&#x3D;B-1b, xN&#x3D;0是最优解————由此可知单纯形法的终止条件。<br>所以要想判断是不是最优算法，可以观察cN是否小于0，如果小于，那么增大对应的xN，并保持其他的xN不变，那么cost会进一步缩小，所以不是最优解。</li><li>怎么移向相邻的基本可行解？<br>移出xB，移入xN。</li></ul><p>步骤：</p><ol><li>转化为标准形式</li><li>找到一个基本可行解</li><li>画tableau</li><li>找enter的变量和exit的变量，把enter的变量那一列通过变换变成单位向量</li><li>如果还有reduced cost是negative的，继续第3步</li><li>直到都是nonnegative，得到xB, xN, objective function value.</li></ol><p>basic feasible solution is such that xB&#x3D;B-1b, xN&#x3D;0<br>reduced cost<br>如果cN&gt;&#x3D;0 基本可行解就是全局最优解（对于最小化问题）<br>对于最大化问题，看是否&lt;&#x3D;0</p><p>Change of basis(for minimization LP): 通过矩阵变换，哪个进(第一行负的进)，哪个出(第一列&#x2F;进的那列对应的行的值)</p><p>Two-phase simplex method(Determine an initial basic feasible solution)看不出明显的基变量的情况下使用(找不到初始基本可行解)，引入人工变量<br>两阶段的第一阶段的目的是找到一个初始的基本可行解，就是用单纯形法消去人工变量，即把人工变量变成非基变量，第二阶段就是从基本可行解出发用单纯形法求线性规划最优解。</p><h1 id="对偶-Duality"><a href="#对偶-Duality" class="headerlink" title="对偶(Duality)"></a>对偶(Duality)</h1><p>如果线性规划（Ⅰ）中的第k个约束条件是等式，则它的对偶规划（Ⅱ）<br>中的第k个变量W无非负限制（W 为自由变量）。</p><p>反之，若原线性规划（Ⅰ）中的第k个变量无非负性要求，则对偶规划（Ⅱ）中的<br>第k个约束为等式。</p><blockquote><p>任一个线性规划得对偶规划都可以写出，其写法为：<br>（ⅰ）将目标函数转化为求最大<br>（ⅱ）将约束条件转化为“≤”型或“&#x3D;”型<br>（ⅲ）写出对偶关系表<br>（ⅳ）据对偶表的规定写出对偶规划</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> FOR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> FOR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exe4:Static BP + Complex, VLIM, Dynamic BP</title>
      <link href="/2023/06/01/Exe4/"/>
      <url>/2023/06/01/Exe4/</url>
      
        <content type="html"><![CDATA[<ol><li><p>为什么不管两条指令离得有多远，都存在WAR冲突？</p></li><li><p>为什么WAR和WAW要推迟Decode，并在解决它们后才能提交？</p></li><li><p>在exe4，为什么I7的decode在C18？<br>有WAR冲突，要保证前面的指令读完了才能进行后面的指令，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">有两条顺序执行的指令：</span><br><span class="line">1. ld $f3, VA($r6)</span><br><span class="line">2. addi $r6,$r6,4</span><br><span class="line">第二条指令什么时候进入decode阶段才能解决WAR？</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">IF</th><th align="center">Ds</th><th align="center">Ds</th><th align="center">Ds</th><th align="center">Ds</th><th align="center">Ds</th><th align="center">Ds</th><th align="center">Ds</th><th align="center">Ds</th><th align="center">D</th><th align="center">IS</th><th align="center">E1</th><th align="center">E2</th><th align="center">E3</th><th align="center">W</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"><strong>F</strong></td><td align="center"><strong>Ds</strong></td><td align="center"><strong>D</strong></td><td align="center"><strong>ISs</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>I9的decode不需要等吗？</p></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空中英语教室1：mental gymnastic</title>
      <link href="/2023/05/31/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BB%83%E4%B9%A0%E5%8F%A3%E8%AF%AD1/"/>
      <url>/2023/05/31/%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%BB%83%E4%B9%A0%E5%8F%A3%E8%AF%AD1/</url>
      
        <content type="html"><![CDATA[<p>concerntration<br>plaque 斑块<br>be aware 知道 意识到<br>beware 小心危险的</p><p>how do you like to exercise?<br>short-term memory<br>have whole brain strength<br>relexation<br>there are other benefits to exercising your mind<br>Phiscal exercise&#x2F;<br>the necessity of mental exercise<br>have been shown to benefit </p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> 沉练 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec5:Dynamic Branch Predictors,Pipelining and Performance,Complex pipelining</title>
      <link href="/2023/05/30/Exe3/"/>
      <url>/2023/05/30/Exe3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec5:ILP,Complex pipelining,Intro to Scheduling</title>
      <link href="/2023/05/30/Lec5/"/>
      <url>/2023/05/30/Lec5/</url>
      
        <content type="html"><![CDATA[<p>Mixing integer and Floating point operations: Complex Pipelining<br>in-order<br>out-of-order<br>怎么样进一步提升性能？scheduling，分为Dynamic Scheduling(hardware) and Static Scheduling(software)</p><h1 id="1-为什么要加ISSUE阶段？"><a href="#1-为什么要加ISSUE阶段？" class="headerlink" title="1. 为什么要加ISSUE阶段？"></a>1. 为什么要加ISSUE阶段？</h1><p>在MIPS架构中，ISSUE阶段是指令流水线中的一个重要阶段，用于指令的调度和发射。ISSUE阶段的作用包括：</p><ol><li><p>指令调度：</p><ul><li>ISSUE阶段对已解码的指令进行调度，确定指令的执行顺序和优先级。它根据不同的调度算法和策略，将指令安排到适当的执行单元上，以最大程度地提高流水线的利用率和性能。</li></ul></li><li><p>数据相关检测：</p><ul><li>ISSUE阶段可以进行<strong>数据相关的检测</strong>，检查当前指令是否存在数据依赖性（例如RAW依赖）。通过检测数据相关性，可以判断指令是否可以立即发射，或者需要等待之前的指令完成。</li></ul></li><li><p>发射指令：</p><ul><li>在ISSUE阶段，经过调度和相关性检测后，合适的指令可以被发射到执行阶段（EX阶段）。发射意味着将指令送入下一阶段进行实际的操作和执行。</li></ul></li></ol><p>ISSUE阶段在流水线中起到关键的调度和控制作用。通过合理的调度和发射策略，可以优化指令的执行顺序，最大程度地避免数据冒险和资源竞争，提高流水线的吞吐量和效率。</p><h1 id="为什么decode执行的时机不一样"><a href="#为什么decode执行的时机不一样" class="headerlink" title="为什么decode执行的时机不一样"></a>为什么decode执行的时机不一样</h1>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec6:Static Scheduling and Very Long Instruction Words(VLIW)</title>
      <link href="/2023/05/30/Lec6/"/>
      <url>/2023/05/30/Lec6/</url>
      
        <content type="html"><![CDATA[<h1 id="VLIW-architecture"><a href="#VLIW-architecture" class="headerlink" title="VLIW architecture"></a>VLIW architecture</h1><p>指令内数据是并行的，没有RAW check</p><h1 id="Static-Scheduling"><a href="#Static-Scheduling" class="headerlink" title="Static Scheduling"></a>Static Scheduling</h1><ul><li>Basic Blocks</li><li>Trace scheduling</li></ul><h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><ol><li>simple code motion</li><li>Loop unrolling &amp; loop peeling</li><li>Software pipeline</li><li>Global code scheduling(across basic block)</li></ol><ul><li>Trace scheduling</li><li>Superblock scheduling</li><li>Hyperblock scheduling</li><li>Speculative Trace scheduling</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>为什么P48页ld和add不存在冲突？</li><li>第70页为什么选择在下面？</li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作地道化表达</title>
      <link href="/2023/05/30/Native%20speaker(work)/"/>
      <url>/2023/05/30/Native%20speaker(work)/</url>
      
        <content type="html"><![CDATA[<h1 id="job-security"><a href="#job-security" class="headerlink" title="job security"></a>job security</h1><h1 id="a-sense-of-fulfillment"><a href="#a-sense-of-fulfillment" class="headerlink" title="a sense of fulfillment"></a>a sense of fulfillment</h1>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> Native Speaker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
            <tag> Native Speaker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English Study Plan</title>
      <link href="/2023/05/30/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2023/05/30/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天看一篇跟读训练课<br>每天背十个地道表达<br>看一个日常对话</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生词本(23周)</title>
      <link href="/2023/05/29/words(week23)/"/>
      <url>/2023/05/29/words(week23)/</url>
      
        <content type="html"><![CDATA[<h1 id="blazer"><a href="#blazer" class="headerlink" title="blazer"></a>blazer</h1><p>[英] · &#x2F;ˈbleɪzə(r)&#x2F;<br>[n.] 西装外套；燃烧器；引线火药枪<br>例句：</p><ol><li>She wore a navy blazer over her white blouse.<br>（她在白衬衫上穿了一件海军蓝西装外套。）</li><li>The pilot lit the blazer to signal for help.<br>（飞行员点燃了引线火药枪以示求救。）</li><li>He fixed the broken blazer on his stove.<br>（他修好了灶具上的坏掉的燃烧器。）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Does it fit?</span><br><span class="line">I forget to mention we have discount at these shoes just today.</span><br><span class="line">I am afraid it&#x27;s not suitable for a birthday party.</span><br><span class="line">I will be right back</span><br><span class="line">old fashioned and faded</span><br><span class="line">It dosen&#x27;t suit you.</span><br><span class="line">be in style 时尚流行</span><br><span class="line">It goes well with your scarf and skirt.</span><br><span class="line">It really match your blue eyes.</span><br></pre></td></tr></table></figure></li></ol><h1 id="blouse"><a href="#blouse" class="headerlink" title="blouse"></a>blouse</h1><p>[英] · &#x2F;blaʊz&#x2F;<br>[n.] 女衬衫；女上衣<br>例句：</p><ol><li>She wore a white blouse and black skirt to the interview. (她穿了一件白色的女衬衫和黑色的裙子去面试。)</li><li>The new collection features a variety of blouses in different colors and patterns. (新系列中有各种颜色和图案的女上衣。)</li><li>I prefer wearing blouses to dresses in the summer because they are more comfortable. (夏天我更喜欢穿女式上装而不是连衣裙，因为它们更舒适。)<br>词源：来自法语blouse，最初指士兵穿的短外套或工作服。</li></ol><h1 id="classy"><a href="#classy" class="headerlink" title="classy"></a>classy</h1><p>[英] · &#x2F;ˈklɑːsi&#x2F;<br>[形容词] 有品位的；高雅的；上等的<br>例句：</p><ol><li>She always dresses so classy.<br>（她总是穿得很有品味。）</li><li>The restaurant has a very classy atmosphere.<br>（这家餐厅氛围非常高雅。）</li><li>He gave a really classy speech at the awards ceremony.<br>（他在颁奖典礼上发表了一篇非常高雅的演讲。）<br>词源：来自class，意为“阶级、等级”，加后缀-y构成形容词。</li></ol><h1 id="pirate"><a href="#pirate" class="headerlink" title="pirate"></a>pirate</h1><p>[英] · &#x2F;ˈpaɪrət&#x2F;<br>[n] 海盗；剽窃者<br>[v] 盗版；掠夺<br>例句：</p><ol><li>The pirates captured the ship and held the crew for ransom. (海盗抓住了那艘船，扣留了船员以勒索赎金。)</li><li>He was accused of pirating software from his company’s competitors. (他被指控从公司竞争对手处盗版软件。)</li><li>The movie studio lost millions due to piracy of their latest film. (电影制片厂因最新电影的盗版而损失数百万。)<br>词源：来自拉丁语pirata，意为“海上强盗”。</li></ol><h1 id="outfit"><a href="#outfit" class="headerlink" title="outfit"></a>outfit</h1><p>[英] · &#x2F;ˈaʊtfɪt&#x2F;<br>[n] 1. 全套装备；全套服装；2. （尤指）一家公司、组织或团体</p><p>例句：</p><ol><li>She wore a stylish outfit to the party.<br>（她穿了一身时髦的衣服去参加派对。）</li><li>The military outfit was well-equipped and highly trained.<br>（这支军队配备精良，训练有素。）</li><li>My sister works for a fashion outfit in New York City.<br>（我姐姐在纽约市的一个时尚公司工作。）</li></ol><p>词源：来自out + fit，意为“完整的设备”。</p><h1 id="bow-tie"><a href="#bow-tie" class="headerlink" title="bow tie"></a>bow tie</h1><p>领结</p><h1 id="flashy"><a href="#flashy" class="headerlink" title="flashy"></a>flashy</h1><p>[英] · &#x2F;ˈflæʃi&#x2F;<br>[形容词] 艳丽的；炫耀的；浮华的<br>例句：</p><ol><li>She wore a flashy dress to the party. (她穿了一件艳丽的裙子去参加派对。)</li><li>His car is too flashy for my taste. (他的车太过浮华，不符合我的口味。)</li><li>The singer’s performance was flashy but lacked substance. (歌手表演很炫耀，但缺乏实质内容。)<br>词源：来自flash（闪光）+ -y后缀</li></ol><h1 id="make-a-bet-on-our-prediction"><a href="#make-a-bet-on-our-prediction" class="headerlink" title="make a bet on our prediction"></a>make a bet on our prediction</h1><p>在这个句子中，“make a bet”意为“下注”。整个句子的意思是“在我们的预测上下注”。</p><p>这个短语也可以用于其他情境，例如：</p><ul><li>He made a bet on the horse race.（他在赛马比赛上下了一笔赌注。）</li><li>I’m not going to make a bet until I know more about the teams.（在我更多地了解队伍之前，我不会进行任何投注。）</li></ul><p>总之，“make a bet”就是指通过支付一定金额或物品来表达对某种结果的信心，并期望获得回报。</p><h1 id="descendant"><a href="#descendant" class="headerlink" title="descendant"></a>descendant</h1><p>[英] · &#x2F;dɪ’sendənt&#x2F;<br>[n] 后代；子孙<br>[adj] 下降的；衰落的<br>例句：</p><ol><li>He is a descendant of the royal family. (他是皇室的后裔。)</li><li>The number of descendants has been decreasing year by year. (后代数量逐年减少。)</li><li>The company’s profits have been on a descendant trend for the past few years. (公司利润在过去几年中一直呈下降趋势。)<br>词源：来自拉丁语“descendere”，意为“下降，传承”。</li></ol><h1 id="Pervasive"><a href="#Pervasive" class="headerlink" title="Pervasive"></a>Pervasive</h1><p>[英] · &#x2F;pəˈveɪsɪv&#x2F;<br>[形] 普遍存在的；无处不在的；渗透性强的<br>例句：</p><ol><li>The pervasive influence of social media is undeniable. (社交媒体的普及影响是不可否认的。)</li><li>The smell of smoke was pervasive throughout the building. (烟味弥漫整个建筑物。)</li><li>Ageism is a pervasive problem in our society. (年龄歧视是我们社会中普遍存在的问题。)<br>词源：来自拉丁语 pervasus，意为“穿过、渗透”。</li></ol><h1 id="undeniable"><a href="#undeniable" class="headerlink" title="undeniable"></a>undeniable</h1><p>[英] · &#x2F;ˌʌndɪˈnaɪəbl&#x2F;<br>[形容词] 不可否认的，无可争辩的<br>中文含义：不可否认的，无法抵赖的</p><p>例句：</p><ol><li>His talent is undeniable.<br>（他的才华是不可否认的。）</li><li>The evidence against him was undeniable.<br>（针对他的证据是无法抵赖的。）</li><li>It is undeniable that climate change is happening.<br>（气候变化正在发生这一点是毋庸置疑的。）</li></ol><p>词源：来自于deny这个单词加上un-前缀构成，意为“不能被否定”。</p><h1 id="negligible"><a href="#negligible" class="headerlink" title="negligible"></a>negligible</h1><p>[英] · &#x2F;ˈneɡlɪdʒəbl&#x2F;<br>[形] 可忽略的，微不足道的<br>例句：</p><ol><li>The difference in price is negligible.<br>（价格上的差异微不足道。）</li><li>The impact of the new policy on the economy is negligible.<br>（新政策对经济的影响微乎其微。）</li><li>The amount of dust in the air was negligible.<br>（空气中灰尘数量可以忽略不计。）<br>词源：<br>来自拉丁语“negligere”，意为“忽视”。</li></ol><h1 id="Ubiquity"><a href="#Ubiquity" class="headerlink" title="Ubiquity"></a>Ubiquity</h1><p>在这个句子中，“Ubiquity”指的是“无处不在”，表示某物或某种情况普遍存在，随处可见。整个句子的意思是“访问无处不在”，即可以随时随地访问。</p><p>这个词也可以用于习语中，例如：“Ubiquitous presence”，意为“到处都有的存在”。其他类似的例子包括：</p><ol><li>The ubiquity of smartphones has changed the way we communicate. (智能手机的普及改变了我们交流方式)</li><li>The ubiquity of fast food restaurants is a sign of our busy lifestyles. (快餐店无处不在反映了我们繁忙的生活方式)</li></ol>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> New word </category>
          
          <category> 2023.5.29 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec4：Dynamic Branch Prediction</title>
      <link href="/2023/05/24/Lec4/"/>
      <url>/2023/05/24/Lec4/</url>
      
        <content type="html"><![CDATA[<h1 id="Branch-History-Table"><a href="#Branch-History-Table" class="headerlink" title="Branch History Table"></a>Branch History Table</h1><p>Taken or not taken<br>为什么1-bit BHT 的错误率是80%? 因为第一次not taken，misprediction后改为taken，最后一次预测错误，所以是misprediction两次<br>为什么2-nested loop taken的错误次数是1+2*9？OK<br>1-bit和2-bit BHT的状态转换图<br>correlating branch predictors</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCS:Part 1</title>
      <link href="/2023/05/23/TCS_1/"/>
      <url>/2023/05/23/TCS_1/</url>
      
        <content type="html"><![CDATA[<h1 id="FSA"><a href="#FSA" class="headerlink" title="FSA"></a>FSA</h1><p> A finite state automaton is (made of):<br>– A finite state set: Q<br>– A finite input alphabet: I<br>– A transition function (partial, in general):</p><h1 id="PDA"><a href="#PDA" class="headerlink" title="PDA"></a>PDA</h1><p>“Finite state machine” + “a stack”: PDA可以记住无限量的信息<br>Input tape + Stack + Control unit<br>This means at state q1, if we encounter an input string ‘a’ and top symbol of the stack is ‘b’, then we pop ‘b’, push ‘c’ on top of the stack and move to state q2.</p><h1 id="TM"><a href="#TM" class="headerlink" title="TM"></a>TM</h1><p>有一个input head和一个memory head</p><h1 id="Nondeterministic-Models"><a href="#Nondeterministic-Models" class="headerlink" title="Nondeterministic Models"></a>Nondeterministic Models</h1><h2 id="Nondeterministic-Finite-state-Automata-NFA"><a href="#Nondeterministic-Finite-state-Automata-NFA" class="headerlink" title="Nondeterministic Finite-state Automata (NFA)"></a>Nondeterministic Finite-state Automata (NFA)</h2><p>“state” the <strong>set</strong> of possible states<br>先构建NFA，再以此构建DFA<br>终结符、非终结符、开始符号</p><p>RL正则语言<br>CFL上下文无关文法<br>GenL通用语言</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> TCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> TCS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph</title>
      <link href="/2023/05/22/FOR_Graph/"/>
      <url>/2023/05/22/FOR_Graph/</url>
      
        <content type="html"><![CDATA[<p>动态规划算法的概念</p><h1 id="Graphs"><a href="#Graphs" class="headerlink" title="Graphs"></a>Graphs</h1><p>G&#x3D;(N,E)<br>nodes and vertices<br>edges and arcs<br>Undirected graph: 边 {i,j}<br>Directed graph: 边 (i,j)<br>The degree of a node<br>The in-degree(out-degree) of a node<br>Nodes u and v are connected<br>A graph is connected(没有孤立点)<br>strongly connected (u and v are connected by a directed path for any u,v\inN)</p><p>Cycle<br>bipartite(no edges connects nodes in the same subset)<br>complete(完全图是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连)</p><p>Given a directed graph G&#x3D;(N,A)<br>the outgoing cut&#x2F; incoming cut(出向割和入向割，都是一些边的集合)</p><h2 id="Graph-reachablility-problem"><a href="#Graph-reachablility-problem" class="headerlink" title="Graph reachablility problem"></a>Graph reachablility problem</h2><p>O(N+E)<br>breath-first search</p><p>G’&#x3D;(N’,E’): subgraph<br>GT&#x3D;(N’,T): connected and acyclic<br>spanning tree</p><h1 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h1><p>n nodes and n-1 edges<br>Any pair of nodes in a tree is connected via a unique path<br>By adding a new edge to a tree, we create a unique cycle<br>T\cup{e}{f} is also a spanning tree</p><h2 id="Optimal-cost-spanning-trees"><a href="#Optimal-cost-spanning-trees" class="headerlink" title="Optimal cost spanning trees"></a>Optimal cost spanning trees</h2><ol><li>connected subgraph containing all the nodes</li><li>subgraph with no cycles</li></ol><ul><li><p><strong>Theorem 1</strong><br>A complete graph with n(n&gt;1) nodes has n^(n-2) spanning trees</p></li><li><p><strong>Theorem 2</strong><br>A tree T is of minimum total cost if and only if no cost-decreasing edge exists</p></li><li><p>Prim’s Algorithm<br>Prim’s算法适用于连通无向图，且边的权重不能为负值。如果图不是连通的，则需要对每个连通分量分别应用Prim’s算法，或者在起始节点的选择上进行调整。</p></li><li><p>Kruskal’s Algorithm<br>给边排序，每次选出最小的边并且不生成循环</p></li></ul><h2 id="Optimal-paths"><a href="#Optimal-paths" class="headerlink" title="Optimal paths"></a>Optimal paths</h2><p><strong>Dijkstra’s Algorithm</strong><br>输出从s到图中各个点的最短路径<br>生成的树不是minimum cost sanning tree<br>不能解决有负边的问题<br><strong>Floyd-Warshall Algorithm</strong><br>Triangular operation<br>D矩阵：从i到j的最短路径<br>P矩阵：从i到j最短路径上j的前趋(predecessor)<br>s&#x3D;1,t&#x3D;4,(u&#x3D;2,u&#x3D;3)</p><p><strong>Optimal paths in DAG(directed acyclic graph)</strong><br>Topological ordering method</p><h3 id="Dynamic-programming-for-shortest-paths-in-DAGs"><a href="#Dynamic-programming-for-shortest-paths-in-DAGs" class="headerlink" title="Dynamic programming for shortest paths in DAGs"></a>Dynamic programming for shortest paths in DAGs</h3><p>\pi 是最短路径，Li是从s到i的最短路径的cost</p><p>The Dynamic programming algorithm for finding <strong>shortest(longest)</strong> paths in DAGs is exact.</p><h4 id="1-Project-planning"><a href="#1-Project-planning" class="headerlink" title="1. Project planning"></a>1. Project planning</h4><p><strong>Critical path method</strong><br>最短时间正着看，最长时间反着看</p><h2 id="Network-flows"><a href="#Network-flows" class="headerlink" title="Network flows"></a>Network flows</h2><p>Ford-Fulkerson’s algorithm is not greedy<br>overall complexity is O(m2kmax)<br>The value of a feasible <em>flow of maximum value</em> &#x3D; the capacity of <em>a cut of minimum capacity</em></p><p>最大流问题：把初始流量加入图中，并表示为反方向的箭头(residual network)</p><p>Minimum Cost Flow Problem: 满足容量约束的前提下，以最低的费用从源节点发送流量到汇节点。</p><p>Bipartite graph</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> FOR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> FOR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生词本(22周)</title>
      <link href="/2023/05/22/words(week22)/"/>
      <url>/2023/05/22/words(week22)/</url>
      
        <content type="html"><![CDATA[<h1 id="competence"><a href="#competence" class="headerlink" title="competence"></a>competence</h1><p>[英] · &#x2F;ˈkɒmpɪt(ə)ns&#x2F;  美 · &#x2F;ˈkɑːmpətəns&#x2F;<br>[n.] 能力；胜任；资格<br>例句：</p><ol><li>She has demonstrated her competence in managing the team. (她已经证明了自己在团队管理方面的能力。)</li><li>The company is looking for someone with technical competence to fill the position. (公司正在寻找一位具备技术能力的人来填补这个职位。)</li><li>A high level of competence is required for this job. (这份工作需要高水平的能力。)</li></ol><h1 id="correspondence"><a href="#correspondence" class="headerlink" title="correspondence"></a>correspondence</h1><p>[英] · &#x2F;ˌkɒr.əˈspɒn.dəns&#x2F;  [美] · &#x2F;ˌkɔːr.əˈspɑːn.dəns&#x2F;<br>[n.] 1. 通信；信件；信函<br>    2. 相似之处；对应关系<br>    3. 符合，一致<br>例句：</p><ol><li>I have been in correspondence with him for several years.<br>（我和他有几年的书信往来。）</li><li>There is a close correspondence between the two accounts.<br>（这两个账户存在密切的对应关系。）</li><li>The results of the experiment are in correspondence with our expectations.<br>（实验结果与我们的预期相符。）</li></ol><h1 id="be-prone-to"><a href="#be-prone-to" class="headerlink" title="be prone to"></a>be prone to</h1><p>易于</p><h1 id="a-little-step-forward"><a href="#a-little-step-forward" class="headerlink" title="a little step forward"></a>a little step forward</h1><p>迈出一小步</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> New word </category>
          
          <category> 2023.5.22 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>口语表达</title>
      <link href="/2023/05/20/oral%20expression/"/>
      <url>/2023/05/20/oral%20expression/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> New word </category>
          
          <category> 2023.5.20 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phiscal Databases</title>
      <link href="/2023/05/16/DB_PhiscalDatabases/"/>
      <url>/2023/05/16/DB_PhiscalDatabases/</url>
      
        <content type="html"><![CDATA[<h1 id="DATA-ACCESS-and-COST-MODEL"><a href="#DATA-ACCESS-and-COST-MODEL" class="headerlink" title="DATA ACCESS and COST MODEL"></a>DATA ACCESS and COST MODEL</h1><p>Main memory: Page<br>Secondary memory: Block</p><p>Assumption: the size of a page &#x3D; the size of a a block</p><p>secondary memory access: seek time(track)+latency time(sector)+transfer time(data transfer)</p><p>File System<br>DBMS</p><p>Primary structure<br>Secondary structures</p><p><strong>3 main types of data access structures:</strong></p><ol><li>Sequential structures(primary typical):</li></ol><ul><li>Entry-sequenced organization(ordered according their order of entry不好找特定数据，不好增加元组的尺寸)</li><li>Sequentially-ordered organization(ordered by the value of a key)</li></ul><ol start="2"><li>Hash-based structures: bucket(of the size of 1 block): folding&#x2F;hashing</li></ol><ul><li>closed hashing(open addressing) eg. linear probing</li><li>open hashing(separate chaining): overflow chains</li></ul><ol start="3"><li>Tree-based structures(seconary typical)</li></ol><ul><li>Balanced trees(B trees)</li><li>B+ trees</li></ul><p>blocks and tuples</p><p>Block factor B&#x3D;SB&#x2F;SR</p><p><strong>Indexes</strong><br>Dense vs. sparse index<br>primary index<br>clustering index<br>secondary index: why the secondary index is necessarily dense次要索引是基于非主键列构建的索引，用于加速对表中数据的访问。<br>注意： A search key is not a primary key! A search key maybe unique or not unique!<br>Hash-based index</p><h1 id="INTRODUCTION-TO-OPTIMIZATION-COSTS-OF-DIFFERENT-ACCESS-MODES"><a href="#INTRODUCTION-TO-OPTIMIZATION-COSTS-OF-DIFFERENT-ACCESS-MODES" class="headerlink" title="INTRODUCTION TO OPTIMIZATION COSTS OF DIFFERENT ACCESS MODES"></a>INTRODUCTION TO OPTIMIZATION COSTS OF DIFFERENT ACCESS MODES</h1><ol><li>Query optimization<br>Optimizations<br><strong>Operations</strong><br>• Selection<br>• Projection<br>• Sort<br>• Join<br>• Grouping<br><strong>Access methods</strong><br>• Sequential<br>• Hash-based indexes<br>• Tree-based indexes</li></ol><p>Sequential scan<br>Cost of lookups: equality ( A&#x3D;v )<br>• Sequential structures with no index<br>  • Lookups are not supported (cost: a full scan)<br>    • Sequentially-ordered structures may have reduced cost<br>• Hash&#x2F;Tree structures<br>  • Supported if A is the search key attribute of the<br>structure<br>  • The cost depends on<br>    • the storage type (primary&#x2F;secondary)<br>    • the search key type (unique&#x2F;non-unique)</p><h2 id="Equality-lookup"><a href="#Equality-lookup" class="headerlink" title="Equality lookup"></a>Equality lookup</h2><ul><li><p>Equality lookup on a primary hash</p></li><li><p>Equality lookup on a secondary hash<br>eg.(non unique search key)为什么是1.3+2&#x3D;3.3？一共有75K个姓氏，有150K个元组，平均一个姓有两个元组，分别在不同的block上，找到这些block用1.3次，在不同的block上找到这两个元组用2次</p></li><li><p>Equality lookup on a primary B+<br>eg.<br>Query predicate on unique search key(3 intermediate levels + 1 leaf node &#x3D; 4)<br>Query predicate NOT on search key(3 intermediate levels + 2K leaf nodes)<br>Query predicate on non unique search key( 3 intermediate levels + 14 leaf blocks &#x3D; 17)</p></li><li><p>Equality lookup on a secondary B+<br>Query predicate on unique search key of STUDENT(3 intermediate levels + 1 leaf<br>node + 1 data block &#x3D; 5)<br>Query predicate not on search key of STUDENT(Index is not useful for this<br>query (full scan costs 1.7k))</p></li><li><p>Equality lookup on a secondary B+<br>Query predicate on non unique search key of STUDENT(Total cost &#x3D; 3 +1 + 2 &#x3D; 6)<br>Query predicate on non unique search key of EXAM(Total cost &#x3D; 3 + 5 + 3.6K ≈ 3.6K)</p></li></ul><h2 id="Interval-lookup"><a href="#Interval-lookup" class="headerlink" title="Interval lookup"></a>Interval lookup</h2><p>Interval lookups A&lt;v , v1&lt;&#x3D; A &lt;&#x3D; v2<br>Tree structures (primary&#x2F;secondary)<br>• Supported if A is the search key</p><ul><li>Interval lookup on primary B+<br>Cost: 1 block per intermediate level + as many leaf blocks as necessary to read all the tuples in the interval<br>(estimated with statistics)</li><li>Interval lookup on secondary B+<br>Cost: 1 block per intermediate level + as many leaf blocks as necessary to read all pointers in the interval + 1 block per each such pointer (to retrieve the tuples)</li></ul><h2 id="operations"><a href="#operations" class="headerlink" title="operations"></a>operations</h2><ol><li>Conjunction &#x2F; disjunction</li><li>sort</li></ol><ul><li>Sort in main memory</li><li>Sort of large files<br>(External Merge Sort)<br>To sort a file stored in N blocks using B buffer pages:<br>现在有N个block，B个buffer，从N个block里选择B个放入内存，对它们进行排序，把排序好的数据放入一个chunk里，这个chunk的长度是B个block，总共有N&#x2F;B个chunk，现在把B个buffer分成B-1个input buffer和1个output buffer，从每个chunk里取出一个block放进input buffer，进行归并排序，放入output buffer中，output buffer满了就写入磁盘，input buffer空了就读进新的block，最后就得到了一个更大的chunk，大小为(B-1)*B，以此类推，最后只剩下一个chunk。<br><strong>cost:</strong><br>Number of passes cost &#x3D; 1 (for initial step) + ⌈log B-1⌈N&#x2F;B⌉ ⌉ (for iterative merge of chunks)<br>Cost &#x3D; 2 (1 for reading + 1 for writing) * N * (# of passes)</li></ul><ol start="3"><li>Join<br>nested-loop</li></ol><ul><li>simple nested-loop 代价一般是平方(b*b)，如果有一个小的表可以放进buffer，那么cost是b+b</li><li>nested-loop join with cache 把特别小的table放进cache，cost是b+b，小表忽略不计，约等于大表</li><li>filtering by condition</li><li>scan and lookup</li></ul><p>merge-scan join</p><ul><li>sort + merge-scan join<br>c&#x3D;b+b<br>if not sorted, 2<em>b</em>(# of passes)<br>• The ordered full scan is possible for a table if the primary storage is <strong>sequentially ordered wrt the join attribute</strong> or a <strong>B+ on the join attribute is defined</strong></li></ul><p>为什么叶子的数量不同？primary index和second index</p><p>hashed join<br>cost&#x3D;b+b</p><h2 id="COST-BASED-OPTIMIZATION"><a href="#COST-BASED-OPTIMIZATION" class="headerlink" title="COST-BASED OPTIMIZATION"></a>COST-BASED OPTIMIZATION</h2>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> DB2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trigger</title>
      <link href="/2023/05/16/DB_Trigger/"/>
      <url>/2023/05/16/DB_Trigger/</url>
      
        <content type="html"><![CDATA[<h1 id="Event-Condition-Action"><a href="#Event-Condition-Action" class="headerlink" title="Event-Condition-Action"></a>Event-Condition-Action</h1><p>Execution mode: before or after</p><h1 id="Granularity-of-events"><a href="#Granularity-of-events" class="headerlink" title="Granularity of events:"></a>Granularity of events:</h1><p>Row-level granularity(for each row)—once for each tuple(less efficient)<br>Statement-level granularity(for each statement)—only once for each activating statement</p><h1 id="Transition-Variables"><a href="#Transition-Variables" class="headerlink" title="Transition Variables"></a>Transition Variables</h1><p>Row-level: tuple variables<br>Statement-level: table variables</p><blockquote><p>在数据库中，过渡变量（transition variable）是在触发器中使用的一种特殊变量类型。它们用于引用与触发器相关的行或数据。</p></blockquote><p>当触发器在数据库操作（如插入、更新、删除）发生时被触发时，过渡变量提供了对相关数据的访问。这些变量的值可以在触发器的动作部分使用，以执行特定的操作或进行其他处理。</p><p>过渡变量的名称和用法可能会根据具体的数据库系统和触发器定义而有所不同。在一些常见的数据库系统中，以下是几个常用的过渡变量：</p><p style="color: #33CC00;"><b>OLD：表示在更新或删除触发器中引用被修改或删除的旧数据。它可以用于访问操作之前存在的值。</b></p><p style="color: #33CC00;"><b>NEW：表示在插入或更新触发器中引用新插入或修改的数据。它可以用于访问操作之后的值。</b></p><h1 id="Triggers-in-SQL-1999-Syntax"><a href="#Triggers-in-SQL-1999-Syntax" class="headerlink" title="Triggers in SQL:1999, Syntax"></a>Triggers in SQL:1999, Syntax</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create trigger &lt;TriggerName&gt;</span><br><span class="line">&#123; before | after &#125;</span><br><span class="line">&#123; insert | delete | update [of &lt;Column&gt;] &#125; on &lt;Table&gt;</span><br><span class="line">referencing &#123; [ old table [as] &lt;OldTableAlias&gt; ]</span><br><span class="line">[ new table [as] &lt;NewTableAlias&gt; ] |</span><br><span class="line">[ old [row] [as] &lt;OldTupleName&gt; ]</span><br><span class="line">[ new [row] [as] &lt;NewTupleName&gt; ] &#125;</span><br><span class="line">[ for each &#123; row | statement &#125; ]</span><br><span class="line">[ when &lt;Condition&gt; ]</span><br><span class="line">&lt;SQLProceduralStatement&gt;</span><br></pre></td></tr></table></figure><h1 id="AFTER-trigger"><a href="#AFTER-trigger" class="headerlink" title="AFTER trigger"></a>AFTER trigger</h1><h2 id="Insertion-of-a-new-tuple-into-T1"><a href="#Insertion-of-a-new-tuple-into-T1" class="headerlink" title="Insertion of a new tuple into T1"></a>Insertion of a new tuple into T1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 创建T1表</span><br><span class="line">CREATE TABLE T1 (</span><br><span class="line">  ID INT PRIMARY KEY,</span><br><span class="line">  VALUE VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建T2表</span><br><span class="line">CREATE TABLE T2 (</span><br><span class="line">  ID INT PRIMARY KEY,</span><br><span class="line">  VALUE VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER insert_into_T2</span><br><span class="line">AFTER INSERT ON T1</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line"> ** INSERT INTO **T2 (ID, VALUE) VALUES (NEW.ID, NEW.VALUE);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>NEW就是transition variable</p><h2 id="Deletion-of-a-tuple-from-T1"><a href="#Deletion-of-a-tuple-from-T1" class="headerlink" title="Deletion of a tuple from T1"></a>Deletion of a tuple from T1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER delete_from_T2</span><br><span class="line">AFTER DELETE ON T1</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">  DELETE FROM T2 WHERE ID = OLD.ID;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER update_T2</span><br><span class="line">**AFTER UPDATE OF VALUE ON** T1</span><br><span class="line">WHEN NEW.ID=OLD.ID</span><br><span class="line">FOR EACH ROW</span><br><span class="line">  UPDATE T2 SET T2.VALUE = NEW.VALUE </span><br><span class="line">  WHERE ID = NEW.ID;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Conditional-replication"><a href="#Conditional-replication" class="headerlink" title="Conditional replication"></a>Conditional replication</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER COND_REPL_INS</span><br><span class="line">AFTER INSERT ON T1</span><br><span class="line">FOR EACH ROW</span><br><span class="line">WHEN (old.VALUE&gt;=10)</span><br><span class="line">**INSERT INTO T2 VALUES**(new.ID,new.VALUE)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER COND_REPL_DEL</span><br><span class="line">AFTER DELETE ON T1</span><br><span class="line">FOR EACH ROW</span><br><span class="line">WHEN(old.VALUE&gt;=10)</span><br><span class="line">**DELETE FROM T2 WHERE** T2.ID=old.ID</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER Cond_REPL_UPD_1 –- new relevant tuple, replicate</span><br><span class="line">**AFTER UPDATE OF VALUE ON T1 WHEN new.ID = old.ID**</span><br><span class="line">FOR EACH ROW</span><br><span class="line">WHEN (old.VALUE &lt; 10 AND new.VALUE &gt;= 10)</span><br><span class="line">**INSERT INTO T2 VALUES** (new.ID, new.VALUE);</span><br><span class="line">CREATE TRIGGER Cond_REPL_UPD_2 –- already replicated tuple changed, propagate</span><br><span class="line">AFTER UPDATE OF VALUE ON T1 WHEN new.ID = old.ID</span><br><span class="line">FOR EACH ROW</span><br><span class="line">WHEN (old.VALUE &gt;= 10 AND new.VALUE &gt;= 10 AND old.VALUE != new.VALUE)</span><br><span class="line">**UPDATE T2 SET **T2.VALUE = new.VALUE WHERE T2.ID = new.ID</span><br><span class="line">CREATE TRIGGER Cond_REPL_UPD_3 –- replicated tuple no longer relevant: delete</span><br><span class="line">AFTER UPDATE OF VALUE ON T1 WHEN new.ID = old.ID</span><br><span class="line">FOR EACH ROW</span><br><span class="line">WHEN (old.VALUE &gt;= 10 AND new.VALUE &lt; 10)</span><br><span class="line">**DELETE FROM T2 WHERE** T2.ID = new.ID; </span><br></pre></td></tr></table></figure><h1 id="BEFORE-x2F-AFTER-trigger"><a href="#BEFORE-x2F-AFTER-trigger" class="headerlink" title="BEFORE&#x2F;AFTER trigger"></a>BEFORE&#x2F;AFTER trigger</h1><p>具体来说，”before” 触发器通常与数据库中的表相关联。当特定的操作（如插入、更新或删除数据）被执行之前，触发器会自动触发。触发器可以在数据<strong>被提交到数据库之前</strong>进行额外的验证、转换或处理。</p><p>以下是一些常见的使用情况：</p><ol><li><p>数据验证：通过 “before” 触发器，可以在执行插入或更新操作之前对数据进行验证。例如，你可以检查某些字段是否满足特定的条件或约束，如果不满足，则阻止操作执行，并返回错误消息。</p></li><li><p>数据转换：触发器还可以用于在数据被插入或更新之前对其进行转换。例如，你可以在插入数据之前将其格式化为特定的方式，或者在更新数据之前对其进行计算或清理。</p></li><li><p>数据补全：有时，在插入或更新数据时，可能需要根据其他表中的值自动填充某些字段。通过使用 “before” 触发器，你可以查询其他表并根据需要补全数据。</p></li><li><p>审计跟踪：触发器还可以用于在执行数据库操作之前记录审计日志。你可以捕获正在进行的操作以及相关的元数据，例如时间戳、执行用户等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER NO_NEGATIVE_VALUES</span><br><span class="line">BEFORE UPDATE of VALUE ON T1</span><br><span class="line">FOR EACH ROW</span><br><span class="line">WHEN (new.VALUE &lt; 0)</span><br><span class="line">SET new.VALUE=0; -- this &quot;modifies the modification&quot;</span><br></pre></td></tr></table></figure></li></ol><h1 id="row-vs-statement"><a href="#row-vs-statement" class="headerlink" title="row vs. statement"></a>row vs. statement</h1><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>• Statement:<br>DELETE FROM T1 WHERE VALUE &gt;&#x3D; 5;<br>• Trigger:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER ST_REPL_DEL</span><br><span class="line">AFTER DELETE ON T1</span><br><span class="line">REFERENCING OLD TABLE AS OLD_T</span><br><span class="line">FOR EACH STATEMENT --all tuples considered at once</span><br><span class="line">DELETE FROM T2 WHERE T2.ID IN</span><br><span class="line">(SELECT ID FROM OLD_T); -- no need to add where OLD_T.value &gt;=10</span><br></pre></td></tr></table></figure><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p>• Statement:<br>INSERT INTO T1 (Id, Value) VALUES (4, 5), (5, 10), (6, 20);<br>Trigger:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER ST_REPL_INS</span><br><span class="line">AFTER INSERT ON T1</span><br><span class="line">REFERENCING NEW TABLE AS NEW_T</span><br><span class="line">**FOR EACH STATEMENT** --all tuples considered at once</span><br><span class="line">INSERT INTO T2</span><br><span class="line">(SELECT ID, VALUE</span><br><span class="line">FROM NEW_T WHERE NEW_T.VALUE &gt;= 10);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER REPLIC_INS</span><br><span class="line">AFTER UPDATE ON T1</span><br><span class="line">REFERENCING OLD TABLE AS OLD_T NEW TABLE AS NEW_T</span><br><span class="line">FOR EACH STATEMENT</span><br><span class="line">DELETE FROM T2 --delete all updated rows</span><br><span class="line">WHERE T2.ID IN (SELECT ID FROM OLD_T);--删除所有更新过的行</span><br><span class="line">INSERT INTO T2 --reinsert only relevant rows</span><br><span class="line">(SELECT ID, VALUE FROM NEW_T</span><br><span class="line">WHERE NEW_T.VALUE &gt;= 10);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> DB2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Concurrency Control</title>
      <link href="/2023/05/16/DB_Concurrency%20Control/"/>
      <url>/2023/05/16/DB_Concurrency%20Control/</url>
      
        <content type="html"><![CDATA[<h1 id="Anomalies"><a href="#Anomalies" class="headerlink" title="Anomalies"></a>Anomalies</h1><ol><li>Lost update</li><li>Dirty read</li><li>Nonrepeatable read</li><li>Phantom update</li><li>Phantom insert</li></ol><h1 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h1><ul><li>Serial-Serializable-ALL</li><li><strong>View-serializability</strong>(the same reads-from relationship and final writes)——判断起来时空复杂度太高</li><li><strong>Conflict-serializability</strong>(更高的要求，更简单的判断方法)——conflict graph(if there is no cycles in the graph)<blockquote><p>怎么找equivalent serial schedule？ 删节点</p></blockquote></li></ul><h1 id="approaches"><a href="#approaches" class="headerlink" title="approaches"></a>approaches</h1><h2 id="1-Lock"><a href="#1-Lock" class="headerlink" title="1. Lock"></a>1. Lock</h2><p><strong># pessimistic concurrency control</strong></p><ul><li><p><strong>r_lock(shared lock), w_lock(exclusive lock)</strong></p></li><li><p><strong>Two-Phase Locking (<em>short duration locks</em>)</strong><br>  解决non-repeatable read<br>  释放锁后不能申请任何别的锁 (growing phase-&gt;plateau-&gt;shrinking phase)<br>  VSR&lt;CSR&lt;2PL</p></li><li><p><strong>Strict 2PL (<em>long duration locks</em>)</strong><br>  解决dirty read<br>  commit&#x2F;rollback 后才能释放锁</p></li><li><p><strong>Predicate locks</strong><br>  the lock on all tuples satisfying the predicate</p></li><li><p><strong>Update lock</strong><br>  解决丢失更新的问题，事务T1在请求升级SL为UL时，必须保证没有别的事务的SL<br>  不能直接从SL升级到XL，必须经过UL<br>  可以直接获得XL,SL,UL,先读后写，先给UL<br>  Each transaction can commit right after its last operation.</p></li><li><p><strong>Hierarchical locking</strong><br>  自上而下请求资源<br>  自下而上释放锁<br>  schema, table, fragment, page, tuple, field</p></li><li><p><strong>Intention Locking Scheme</strong><br>  5 lock modes: SL, XL, ISL, IXL, SIXL<br>  Protocol:<br>  request: top-down<br>  release: bottom-up<br>  request <strong>SL or ISL</strong>——equally or more restrictive lock**(ISL or IXL)** on its “parent”<br>  request <strong>IXL,XL,SIXL</strong>——-equally or more restrictive lock(<strong>SIXL or IXL</strong>) on its “parent”</p></li></ul><h2 id="2-Timestamps"><a href="#2-Timestamps" class="headerlink" title="2. Timestamps"></a>2. Timestamps</h2><p><strong># optimistic concurrency control</strong></p><h1 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h1><ul><li>Lock graph</li><li>Wait-for graph(循环有死锁)</li></ul><h2 id="Deadlock-Resolution-Techniques"><a href="#Deadlock-Resolution-Techniques" class="headerlink" title="Deadlock Resolution Techniques"></a>Deadlock Resolution Techniques</h2><h3 id="1-Timeout"><a href="#1-Timeout" class="headerlink" title="1. Timeout"></a>1. Timeout</h3><h3 id="2-Deadlock-prevention"><a href="#2-Deadlock-prevention" class="headerlink" title="2. Deadlock prevention"></a>2. Deadlock prevention</h3><ul><li>resourse-based prevention<br>  事务必须一次请求所有资源<br>  但事务很难一下子明确所有需求</li><li>transaction-based prevention<br>  不要让老的等待年轻的<ul><li>Preemptive (杀掉占有资源的事务——wound-wait)<br>  老的抢（杀掉年轻的），年轻的等</li><li>Non-preemptive (杀掉请求资源的事务——wait-die)<br>  老年人申请年轻人的资源——wait<br>  年轻人申请老年人的资源——die(abort+restart)</li></ul></li></ul><h3 id="3-Deadlock-detection"><a href="#3-Deadlock-detection" class="headerlink" title="3. Deadlock detection"></a>3. Deadlock detection</h3><ul><li>Distributed Deadlock Detection<br><strong>Obermarck’s algorithm</strong></li></ul><h1 id="Timestamps"><a href="#Timestamps" class="headerlink" title="Timestamps"></a>Timestamps</h1><ol><li>Syntax: timestamp &#x3D; event-id.node-id</li></ol><ul><li>event-ids are unique <strong>at each node</strong></li><li>同一个node中的node-id都一样</li></ul><ol start="2"><li>Note that the notion of time is “<strong>lexical</strong>”: timestamp 5.1 “occurs before”<br>timestamp 5.2</li><li>算法（Lamport方法）：如果接收到来自“未来”的消息，则使用“碰撞规则”将<strong>接收事件</strong>的时间戳推迟到<strong>发送事件</strong>的时间戳之后，以避免出现此类情况。</li></ol><ul><li>如果我从你那里接收到一个时间戳大于我的最后一个发出的时间戳的消息，则更新当前时间戳以超过您的。</li><li><strong>rts只需要和WTM比，wts要和WTM和RTM比</strong><br>The scheduler receives read&#x2F;write requests tagged with<br>the timestamp of the requesting transaction:<br>• rts(x):<br>• If ts &lt; WTM(x) the request is rejected and the transaction is killed<br>• Else, access is granted and we set <strong>RTM(x) &#x3D; max(RTM(x), ts)</strong><br>• wts(x):<br>• If ts &lt; RTM(x) or ts &lt; WTM(x) the request is rejected and the<br>transaction is killed<br>• Else, access is granted and we set <strong>WTM(x) &#x3D; ts</strong></li></ul><ol start="4"><li>2PL vs. TS  incomparable</li><li>TS and CSR<br>• TS &#x3D;&gt; CSR</li><li>TS and dirty reads</li><li><strong>Thomas Rule</strong>：reduce kill rate</li></ol><p><strong>处理wts时</strong>，<br>ts &lt; RTM(x)：杀<br>ts &lt; WTM(x)：过时，跳过<br>else：授权访问</p><ul><li>TS with Thomas Rule maybe not in VSR</li></ul><h2 id="TS-mono"><a href="#TS-mono" class="headerlink" title="TS-mono"></a>TS-mono</h2><p>• rts(x):<br>• If ts &lt; WTM(x) the request is rejected and the transaction is killed<br>• Else, access is granted and we set RTM(x) &#x3D; max(RTM(x), ts)<br>• wts(x):<br>• If ts &lt; RTM(x) or ts &lt; WTM(x) the request is rejected and the<br>transaction is killed<br>• Else, access is granted and we set WTM(x) &#x3D; ts</p><h2 id="Multiversion-Concurrency-Control"><a href="#Multiversion-Concurrency-Control" class="headerlink" title="Multiversion Concurrency Control"></a>Multiversion Concurrency Control</h2><p>WTMi(x), RTM(x)</p><h3 id="Mechanism"><a href="#Mechanism" class="headerlink" title="Mechanism:"></a>Mechanism:</h3><p>• <strong>rts(x) is always accepted</strong>. A copy xk is selected for reading<br>such that:<br>• If ts &gt;&#x3D; WTMN(x), then k &#x3D; N<br>• Else take k such that WTMk(x) &lt;&#x3D; ts &lt; WTMk+1(x)<br>• <strong>wts(x):</strong><br>• If ts &lt; RTM(x) the request is rejected<br>• Else a new version is created for timestamp ts (N is incremented)<br>• WTM1(x), …, WTMN(x) are the new versions, kept sorted from<br>oldest to youngest<br>• NB: unlike here, in real systems based, e.g., on snapshot isolation<br>(see later) and, for simplicity, in the exercises, if ts &lt; WTMN(x),<br>the request is rejected</p><p>做题心得：</p><ol><li>lost update: 必须是interleaved的两个r-w，只有w不行</li><li>phantom update: 必须有一个全局的限制条件，update后全局条件没变，但因为某些事务不知道所有的update，所以它觉得全局条件不满足了(两个读，一个读改之前的，一个读已经被别的事务改过的)</li><li>属于VSR但不属于CSR的schedule都有一个共同的特点：他的冲突图中存在因为一对blind writes而产生的一对边导致的循环(w1,w2,w3)<br>什么是blind write？ 对于同一个资源，不是最后一个操作，后续还有写<br>找到blind write之后，调换它们的位置，看看能不能消除循环</li></ol><p>几个快速判断VSR的方法：</p><ul><li>if has the same reads-from and final writes(一般只有是VSR的时候这种方法才有效，因为需要和serial schedule比对)</li><li>找找有没有blind write，调换它们的位置，看看能不能消除循环</li><li>看看找到相互冲突的两对，如果不能调整任何一对的顺序，循环不能消除，说明不是VSR</li><li>找每个循环的共同部分，看看能不能打破循环</li></ul><hr><ol start="4"><li><p>2PL(全都锁上才能释放)<br>两个注意：<br>(1)Same resource: 只有当资源R空闲的时候才能上锁(UR &lt; LR)<br>(2)Same transaction: 所有的解锁必须在上锁之前(下面的锁&lt;上面的放锁)<br>怎么判断：画表，一个一个标，找到那些必须提前加锁的时机，找到加锁和放锁的交界<br>2PL属于CSR, 可以先判断CSR</p></li><li><p>Strict-2PL<br>commit&#x2F;rollback以后才能释放锁。<br>怎么判断：找到每个事务的最后一个操作，再看在那之前需不需要提前释放锁</p></li><li><p>Obermarck<br>把i&gt;j传送给对应的node</p></li><li><p>Update lock可以消除所有的死锁吗？<br>答：不能，<br>• Clearly deadlocks are possible in the presence of UL. Indeed, UL only makes deadlock less likely, by preventing one type of (very frequent) deadlock, due to update patterns, when two transactions compete for the same resource (e.g., r1(x) r2(x) w1(x) w2(x)). Consider two distinct resources X Y, and two transactions that want to access them in this order:<br>r1(X) r2(Y) w1(Y) w2(X).<br>• It is likely that they end up in deadlock, especially if the system on which they run applies 2PL. UL is totally irrelevant here, because there is no update pattern.</p></li></ol><hr><ol start="8"><li>怎么判断TS-mono？<br>找r-w, w-r, w-w对，看看有没有too late<br>TS(mono)属于CSR，可以以此判断</li><li>怎么判断TS-multi？<br>找晚的w, 小于RTM</li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> DB2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周报1</title>
      <link href="/2023/05/15/weekly1/"/>
      <url>/2023/05/15/weekly1/</url>
      
        <content type="html"><![CDATA[<h1 id="Plan"><a href="#Plan" class="headerlink" title="Plan"></a>Plan</h1><ol><li>复习完MIDA1，看至少一半的exe课</li><li>复习完ACA(一天看两节课，十天看完) 每天五个小时</li><li>看FOR(2)和DB(3)的PPT，并做题</li><li>写周报，分享感受，The long season</li><li>第一轮考7门：TCS（12）,ACA（13）,CI（15）,FOR（16）, <del>CS（21）</del>, DB2（23）在ACA考试前只需要把理论和TA看完就行, MIDA1（24）, <del>MIDA2,</del>  </li><li>到12点做一个TCS，下午做完物理数据库和trigger，晚上做两个mida。睡前看两个for<br>是一个exe(3天看完)，<br>for做完 1，2单元的题</li></ol><h1 id="发现的一些有趣的频道"><a href="#发现的一些有趣的频道" class="headerlink" title="发现的一些有趣的频道"></a>发现的一些有趣的频道</h1><p><a href="https://www.xiaoyuzhoufm.com/podcast/640ee2438be5d40013fe4a87">硬地骇客</a></p><p><a href="https://www.xiaoyuzhoufm.com/podcast/640ee2438be5d40013fe4a87">豌豆花下猫（关于Python）</a></p><p><a href="https://brr.fyi/">被派到南极洲工作的程序员</a><br>作者作为 IT 工程师被派到南极洲工作，博客是记录他在南极生活的点点滴滴</p><h1 id="看到的一些推特好帖"><a href="#看到的一些推特好帖" class="headerlink" title="看到的一些推特好帖"></a>看到的一些推特好帖</h1><h2 id="1-如何提高专注度"><a href="#1-如何提高专注度" class="headerlink" title="1. 如何提高专注度"></a>1. 如何提高专注度</h2><p>**转自博主Dexter Yang(@dexteryy)**，<br><a href="https://twitter.com/dexteryy/status/1629491278886076416">方法</a><br>想要通过正念（mindfulness&#x2F;meditation）来恢复对当下的感知、减慢时间流逝、用内啡肽替代多巴胺、提升专注能力、降低压力的消极影响，我觉得骑车是最有效果的（图2），比那些冥想app里的付费课程（图1）强多了。<br>方法总结：</p><ol><li>不要听播客不要听播客不要听播客（凡是抢占注意力的都不要碰）。<br>(1&#x2F;4)</li><li>开降噪，听音乐。最好是 citypop、blues  那样积极向上的音乐（这两种本来就源自上班族和黑人奴工振奋情绪排解压力的需求）。</li><li>公路车和共享单车都可以。</li><li>把注意力放在自身感受和眼前情景上，只接受下意识的瞬间的发散和思考。</li><li>天气要好，一定要有阳光，推荐下午出发，去程有落日返程有夜景。</li><li>路线选择类似 city walk，尽量途径那些有河、有沿街生态、城市机理细密有机多样的地方。</li></ol>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生词本</title>
      <link href="/2023/05/15/words(week21)/"/>
      <url>/2023/05/15/words(week21)/</url>
      
        <content type="html"><![CDATA[<p>#1.  predicate<br>[英] · &#x2F;ˈprɛdɪkət&#x2F;<br>[n.] 谓语；断言<br>[v.] 断言；预示</p><p>例句：</p><ol><li>The predicate of this sentence is “is a teacher”. (这个句子的谓语是“是一名老师”。)</li><li>She predicates her success on hard work and determination. (她认为自己的成功取决于努力和决心。)</li><li>In logic, the predicate refers to the part of a proposition that expresses what is said about the subject. (在逻辑学中，谓词指表达主语所说内容的命题部分。)</li></ol><p>#2. sparingly<br>[英] · &#x2F;ˈspeərɪŋli&#x2F;<br>[副词] 节约地，保守地</p><p>例句：</p><ol><li>She uses water sparingly when she washes dishes. (她洗碗时很节水。)</li><li>He doles out praise sparingly, so when he compliments you, it really means something. (他不轻易夸赞别人，所以当他表扬你时，真的有意义。)</li><li>The company has been spending money more sparingly since the economic downturn began. (自从经济衰退开始以来，公司一直在更加节省开支。)</li></ol><p>#3. anticipate<br>[英] · &#x2F;ænˈtɪs.ɪ.peɪt&#x2F;  美 · &#x2F;ænˈtɪs.ə.peɪt&#x2F;<br>[v] 预期；预料；期望<br>例句：</p><ol><li>I anticipate a difficult exam tomorrow. (我预计明天会有一场难考试。)</li><li>The company is anticipating an increase in profits this year. (公司预计今年利润将增加。)</li><li>She anticipated his every move and was always one step ahead of him. (她能够预见他的每一个动作，总是比他先一步。)</li></ol><p>#4. mitigate<br>[英] · &#x2F;ˈmɪtɪɡeɪt&#x2F;  [美] · &#x2F;ˈmɪtəˌgeɪt&#x2F;<br>[v] 缓和，减轻；使缓和，使减轻<br>例句：</p><ol><li>The doctor prescribed some medicine to mitigate the pain. (医生开了一些药来缓解疼痛。)</li><li>We need to take measures to mitigate the impact of climate change. (我们需要采取措施来减轻气候变化的影响。)</li><li>The company implemented policies to mitigate risks in their investments. (公司实施了政策以降低其投资风险。)</li></ol><p>#5. replication<br>[英] · &#x2F;ˌrɛplɪˈkeɪʃən&#x2F;<br>[n.] 复制；复刻；重复<br>例句：</p><ol><li>DNA replication is a fundamental process in cell division. (DNA的复制是细胞分裂中的基本过程。)</li><li>The artist made a perfect replication of the famous painting. (艺术家完美地复制了那幅著名画作。)</li><li>The study aimed to investigate the replication of previous research findings. (这项研究旨在调查之前研究结果的重现性。)</li></ol><p>#6. magnitude<br>[英] · &#x2F;ˈmæɡnɪtjuːd&#x2F;  美 · &#x2F;ˈmæɡnətuːd&#x2F;<br>[n.] 大小；量级；重要性<br>[adj.] 巨大的，重要的<br>例句：</p><ol><li>The magnitude of the earthquake was measured at 7.0 on the Richter scale. (这次地震的大小被测定为里氏7.0级。)</li><li>We cannot underestimate the magnitude of this problem. (我们不能低估这个问题的重要性。)</li><li>The company has achieved a magnitude of success that no one could have predicted. (该公司已经取得了一个无人能够预料到的巨大成功。)</li></ol><p>#7. vice-versa<br>反之亦然</p><p>#8.  高出四个数量级<br>is 4 orders of magnitude higher than</p><p>#9. • In “I&#x2F;O bound” applications the cost exclusively depends on the number of accesses to secondary memory<br>在“I&#x2F;O bound”应用程序中，成本完全取决于对辅助存储器的访问次数。</p><p>在这个句子中，“exclusively”的意思是“仅仅、唯一地”。它强调了成本只与对辅助存储器的访问次数有关，而与其他因素无关。 </p><p>举例来说，如果一个人说他只喜欢吃巧克力蛋糕，那么他就是“exclusively”喜欢吃巧克力蛋糕。 </p><p>其他类似的表达方式包括：</p><ul><li>solely: 仅仅、单独地</li><li>purely: 纯粹地、完全地</li></ul><p>例如：她纯粹是为了钱才去做那份工作。（She did the job purely for money.）</p><p>#10. make limited use of<br>#11. distinctive<br>[英] · &#x2F;dɪˈstɪŋktɪv&#x2F;<br>[形容词] 独特的；有特色的；与众不同的<br>例句：</p><ol><li>Her distinctive voice made her stand out in the crowd. (她独特的声音使她在人群中脱颖而出。)</li><li>The building’s architecture is quite distinctive and easily recognizable. (这座建筑物的建筑风格非常独特，很容易辨认。)</li><li>The company has a distinctive approach to marketing that sets it apart from its competitors. (该公司具有一种独特的营销方式，使其与竞争对手区别开来。)</li></ol><p>#12. Obsolete<br>[英] · &#x2F;ˌɒbsəˈliːt&#x2F;  美 · &#x2F;ˌɑːbsəˈliːt&#x2F;<br>[形] 过时的；废弃的；淘汰的<br>例句：</p><ol><li>The old computer system is now obsolete and needs to be replaced. (这个旧电脑系统现在已经过时了，需要被替换。)</li><li>This law has become obsolete and no longer serves its intended purpose. (这项法律已经过时了，不再起到原本预期的作用。)</li><li>Many traditional skills have become obsolete in the age of automation and technology. (在自动化和技术发展的时代，许多传统技能已经变得过时了。)</li></ol>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> New word </category>
          
          <category> 2023.5.15 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exe1</title>
      <link href="/2023/05/07/Exe1/"/>
      <url>/2023/05/07/Exe1/</url>
      
        <content type="html"><![CDATA[<h1 id="Performance-Amdhal’s-Law-Pipeline"><a href="#Performance-Amdhal’s-Law-Pipeline" class="headerlink" title="Performance, Amdhal’s Law, Pipeline"></a>Performance, Amdhal’s Law, Pipeline</h1><ol><li>为什么MIPS架构五级流水线的指令译码阶段和写回阶段可以被分成两部分？</li></ol><p>在MIPS架构中，指令译码阶段的指令解码和操作数寻址可以在同一个阶段中实现。这是因为在MIPS架构中，指令的格式是固定的，指令中的寄存器编号和偏移量等操作数地址相关信息都在指令的特定位置上。</p><p>在指令译码阶段，指令解码和操作数寻址这两个小部分的执行顺序是有先后关系的。</p><p>具体来说，指令解码必须在操作数寻址之前执行，因为指令解码需要识别指令的类型和需要访问的寄存器和存储器，这些信息是操作数寻址所必需的。如果操作数寻址在指令解码之前执行，那么CPU就无法确定需要访问的寄存器和存储器，无法进行有效的操作数寻址。</p><p>因此，在指令译码阶段，指令解码和操作数寻址必须按照指定的顺序依次执行。通常情况下，指令解码和操作数寻址可以在同一个时钟周期内完成，因此它们被视为一个阶段，但是在实际的设计中，也可以将它们分别实现为两个子阶段，以便更好地控制CPU的时序和性能。</p><ol start="2"><li>MIPS有哪些指令</li></ol><p>MIPS架构定义了多种指令，包括算术指令、逻辑指令、移位指令、条件分支指令、跳转指令、访存指令等等。以下是MIPS指令的一些常见分类：</p><p>算术指令：包括加、减、乘、除等指令。例如：add、addi、addu、addiu、sub、mult、div等。</p><p>逻辑指令：包括与、或、异或、非等指令。例如：and、or、xor、nor等。</p><p>移位指令：包括左移、右移等指令。例如：sll、srl、sra等。</p><p>条件分支指令：包括条件分支和条件跳转等指令。例如：beq、bne、blez、bgtz等。</p><p>跳转指令：包括无条件跳转指令和子程序调用指令等。例如：j、jal、jr等。</p><p>访存指令：包括从内存中读取数据和将数据写入内存等指令。例如：lw、lb、sw、sb等。</p><p>此外，MIPS还支持一些特殊的指令，如异常处理指令、协处理器指令等，这些指令可以用于特殊的计算需求，例如浮点运算等。</p><ol start="3"><li>lw和sw指令</li></ol><p>lw和sw指令是MIPS架构中的访存指令，用于从内存中读取数据和将数据写入内存。它们的具体功能和用法如下：</p><ul><li><p>lw指令：从内存中读取一个字（32位数据），并将其存储到指定的寄存器中。lw指令的语法如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lw $rt, offset($rs)</span><br></pre></td></tr></table></figure><p> 其中，$rt是目标寄存器，offset是偏移量，$rs是基地址寄存器。偏移量表示目标地址相对于基地址的偏移量，可以是一个立即数或者另一个寄存器的值。</p><p> 执行过程如下：首先，CPU将基地址寄存器的值加上偏移量，计算出目标地址；然后，CPU从目标地址中读取一个字（32位数据），并将其存储到目标寄存器中。如果读取过程中发生异常，如地址错误或者访问权限错误等，CPU将产生一个异常，需要进行异常处理。</p></li><li><p>sw指令：将一个字（32位数据）存储到指定的内存地址中。sw指令的语法如下：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sw $rt, offset($rs)</span><br></pre></td></tr></table></figure><p> 其中，$rt是源寄存器，offset是偏移量，$rs是基地址寄存器。偏移量表示目标地址相对于基地址的偏移量，可以是一个立即数或者另一个寄存器的值。</p><p> 执行过程如下：首先，CPU将基地址寄存器的值加上偏移量，计算出目标地址；然后，CPU将源寄存器中的值存储到目标地址中。如果存储过程中发生异常，如地址错误或者访问权限错误等，CPU将产生一个异常，需要进行异常处理。</p></li></ul><p>需要注意的是，偏移量可以是一个有符号的16位整数，因此，lw和sw指令最大可以访问的内存范围是从基地址加上-32768到基地址加上32767的区间。此外，MIPS是一个大端字节序的架构，因此，读取和存储的字节顺序是从高位到低位的。</p><ol start="4"><li>在MIPS处理器中，Forwarding path怎么工作？</li></ol><p>在MIPS处理器中，Forwarding path被广泛用于解决数据冒险（Data Hazard）的问题，提高指令的执行效率。具体地，Forwarding path通常在以下两个阶段被使用：</p><ul><li>执行阶段</li></ul><p>在执行阶段，Forwarding path被用于解决数据冒险。当一个指令需要使用另一个指令的执行结果时，通常会等待前一条指令的结果被写入寄存器后才能继续执行后续指令。但是，如果前一条指令的结果可以直接传递给后续指令，就可以通过Forwarding path来避免等待寄存器的写入。</p><p>在MIPS处理器中，执行阶段的指令通常会产生数据结果，并<strong>将其存储在执行阶段的寄存器中</strong>。如果后续指令需要使用这些结果，则需要在<strong>执行阶段的输出阶段中使用Forwarding path</strong>将数据结果传递给后续指令。</p><ul><li>访存阶段</li></ul><p>在MIPS处理器中，数据访问指令，如lw和sw指令，通常需要在访存阶段中执行。这些指令涉及访问内存或外部设备，因此需要在内存或外部设备中读取或写入数据。</p><p>在访存阶段，如果后续指令需要使用lw指令加载的数据，则需要使用Forwarding path将数据传递给后续指令。类似地，如果后续指令需要将数据存储到内存中，则需要在执行sw指令时使用Forwarding path，以便将数据直接传递给存储器，<strong>而不是等待其被写入寄存器。</strong></p><p>总之，Forwarding path是MIPS处理器中解决数据冒险的重要技术，可以在不需要等待寄存器写入的情况下加速指令的执行，并提高CPU的效率。</p><ol start="5"><li>具体讲一下指令译码阶段要完成哪些工作</li></ol><p>在MIPS五级流水线中，指令译码阶段是第二个阶段，也被称为ID（Instruction Decode）阶段。在这个阶段，处理器会执行以下操作：</p><p>从指令寄存器中取出当前指令，然后将其解码，确定指令类型和操作数。<br>读取寄存器文件中的操作数寄存器的值，并将其存储在指令中的寄存器操作数字段中。<br><em>执行分支和跳转指令的目标地址计算</em>。对于分支指令，需要判断分支是否应该被执行，即判断条件码寄存器中的标志位是否符合指令中的条件码要求；对于跳转指令，需要计算跳转目标地址，并将其存储在指令中的目标地址字段中。<br>为执行阶段准备数据，将指令中的操作数传递给执行阶段，以便执行阶段可以进行操作。<br>总之，<strong>指令译码阶段是将指令翻译成处理器可以理解的指令格式，并将操作数准备好</strong>，以便执行阶段能够使用它们。在这个阶段，处理器还会进行分支和跳转指令的处理，以便指令流能够正确地执行。</p><ol start="6"><li>sw的指令译码阶段要做什么</li></ol><p>在MIPS五级流水线中，sw指令是一种存储数据的指令，它将一个寄存器的值存储到内存中。在指令译码阶段，sw指令需要完成以下工作：</p><ul><li>解码指令，确定指令类型和操作数。对于sw指令，指令类型为存储型指令，其中操作数包括要存储的数据和内存地址。</li><li>读取源寄存器中的数据，即要存储的数据。这需要访问寄存器文件，并从指定的寄存器中读取数据。</li><li>计算内存地址，这需要访问寄存器文件，并从指定的寄存器中读取基地址，然后将偏移量添加到基地址上得到内存地址。偏移量存储在指令的立即数字段中。</li><li>将存储数据和内存地址传递给执行阶段，以便执行阶段能够将数据存储到内存中。<br>需要注意的是，由于存储操作需要访问内存，因此存储操作可能会发生数据冒险问题。如果前面的指令已经修改了要存储的数据，那么该值将不会正确地存储到内存中。为了解决这个问题，MIPS处理器使用了一些技术，如前向传递和暂停插入，以确保数据在正确的时间传递到存储阶段。</li></ul><ol start="7"><li>MIPS写回阶段要完成哪些工作</li></ol><p>在MIPS五级流水线中，写回阶段是最后一个阶段，也是整个指令执行过程的最后一步。在写回阶段，需要完成以下工作：</p><ul><li>读取执行阶段中计算得出的结果，即要写回的数据。这些数据可能来自寄存器或内存，具体取决于执行的指令类型。</li><li>将数据写回到寄存器文件中。要写回的寄存器编号和数据都来自执行阶段。写回操作通常是一个简单的操作，它只需要将数据写入寄存器文件中的指定位置即可。</li><li>如果存在异常，将异常信号传递到控制器中，以便控制器可以采取适当的措施，如中断执行流程或跳转到异常处理程序。</li></ul><ol start="8"><li>写回阶段不是要把数据写回内存吗</li></ol><p>在MIPS架构中，数据存储在寄存器文件或内存中。写回阶段主要是将计算得出的结果写回到<strong>寄存器文件</strong>中，而不是写回到内存中。写回到内存的指令是存储器访问指令，例如sw指令，它们的写回操作在执行阶段中完成。在执行阶段中，存储器访问指令需要计算内存地址、读取要存储的数据，并将它们写回到内存中。当这些操作完成后，执行阶段就结束了，接下来就是写回阶段。在写回阶段，执行阶段计算得出的结果会被写回到寄存器文件中，以便后续的指令可以使用这些结果。所以，写回阶段主要是负责将数据写回到寄存器文件中，而不是写回到内存中。</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lec3</title>
      <link href="/2023/05/07/Lec3/"/>
      <url>/2023/05/07/Lec3/</url>
      
        <content type="html"><![CDATA[<h1 id="Branch-Hazards-and-Static-Branch-Prediction-Techniques"><a href="#Branch-Hazards-and-Static-Branch-Prediction-Techniques" class="headerlink" title="Branch Hazards and Static Branch Prediction Techniques"></a>Branch Hazards and Static Branch Prediction Techniques</h1><h2 id="Three-classes-of-hazards"><a href="#Three-classes-of-hazards" class="headerlink" title="Three classes of hazards"></a>Three classes of hazards</h2><p>现在来看Control Hazards</p><ol><li>Branch Target Address指向else地址</li><li>在EXE阶段末尾算出BTA<br> 在ME结段末更新PC，此时才能取回指令</li><li>Taken&#x2F;Not taken<br>If the branch is <strong>not taken</strong>, the pipeline execution is OK<br>If the branch is <strong>taken</strong>, it is necessary to flush the next <strong>3</strong> instructions<br>in the pipeline and fetched the lw instruction at the branch target<br>address (L1)</li><li><strong>Branch Stalls without Forwarding</strong> 等待3个cycle<br><strong>Branch Stalls with Forwarding</strong> 等待2个cycle</li><li>MIPS processor <code>compares registers</code>, <code>computes branch target address</code> and <code>updates PC</code> during <strong>ID stage</strong>. 只需要stall一个cycle</li></ol><h2 id="Branch-Prediction-Techniques"><a href="#Branch-Prediction-Techniques" class="headerlink" title="Branch Prediction Techniques"></a>Branch Prediction Techniques</h2><h3 id="Static-Branch-Prediction-Techniques-offline"><a href="#Static-Branch-Prediction-Techniques-offline" class="headerlink" title="Static Branch Prediction Techniques(offline)"></a>Static Branch Prediction Techniques(offline)</h3><p>Branch Always Not Taken (Predicted-Not-Taken)<br>Branch Always Taken (Predicted-Taken)<br>Backward Taken Forward Not Taken (BTFNT)<br>Profile-Driven Prediction</p><p><strong>Delayed Branch</strong> : </p><ol><li>From before</li><li>From target</li><li>From fall-through</li></ol><h3 id="Dynamic-Branch-Prediction-Techniques"><a href="#Dynamic-Branch-Prediction-Techniques" class="headerlink" title="Dynamic Branch Prediction Techniques"></a>Dynamic Branch Prediction Techniques</h3><p><strong>Branch Outcome and Branch Target Address are ready at the end of EX statge(3th stage). Conditional branches are solved when PC is updated at the end of the ME stage(4th Stage).The branch decision is taken during the MEM stage(Taken or Not Taken)</strong></p><hr><ol><li>beq和bne指令具体的结构是什么样的</li></ol><p>beq和bne指令的具体结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beq $rs, $rt, offset</span><br><span class="line">bne $rs, $rt, offset</span><br></pre></td></tr></table></figure><p>其中，$rs和$rt是两个要比较的寄存器，offset是要跳转的相对地址。</p><p>这两个指令的作用分别是比较$rs和$rt的值是否相等或不相等，如果相等或不相等则跳转到当前PC值加上offset后的地址。</p><p>例如，如果要比较寄存器$4和$5的值是否相等，如果相等则跳转到当前PC加上8个字节（即2条指令）后的地址，可以使用以下beq指令：</p><p>beq $4, $5, 8</p><p>如果要比较寄存器$6和$7的值是否不相等，如果不相等则跳转到当前PC加上16个字节（即4条指令）后的地址，可以使用以下bne指令：</p><p>bne $6, $7, 16</p><p>这两个指令在程序控制流程中应用广泛，可以用于实现if-else语句、while循环等程序控制结构。</p><ol start="2"><li>beq指令在MIPS处理器中的执行需要经过多个阶段。下面是beq指令在不同阶段的具体工作：</li></ol><ul><li><p>指令获取阶段（Instruction Fetch，IF）：<br>在这个阶段，处理器从指令存储器（Instruction Memory，IM）中读取指令。对于beq指令，处理器将PC（程序计数器）加上4得到当前指令的地址，然后从IM中读取该地址的指令。</p></li><li><p>指令译码阶段（Instruction Decode，ID）：<br>在这个阶段，处理器对指令进行解码，确定需要比较的两个寄存器（$rs和$rt）和跳转的偏移量（offset）。处理器从寄存器堆中读取$rs和$rt的值，将这两个值进行比较。</p></li><li><p>执行阶段（Execute，EX）：<br>在这个阶段，处理器执行比较操作。如果$rs和$rt的值相等，则将PC加上偏移量（offset）后的地址作为下一条指令的地址；否则，继续执行下一条指令。注意，在这个阶段可能会出现数据冒险，需要使用forwarding path来解决。</p></li><li><p>访存阶段（Memory Access，MEM）：<br>在这个阶段，处理器不需要进行任何操作。beq指令不涉及内存的读写操作，因此这个阶段可以省略。</p></li><li><p>写回阶段（Write Back，WB）：<br>在这个阶段，处理器不需要进行任何操作。beq指令不需要将结果写回到寄存器堆中，因此这个阶段也可以省略。</p></li></ul><p>需要注意的是，当beq指令的条件成立时，跳转目标是PC加上偏移量后的地址。因此，偏移量应该是一个相对地址，可以是一个负数。跳转目标的地址计算应该在执行阶段完成，同时需要注意指令地址应该按4字节对齐，因此偏移量需要乘以4。</p><ol start="3"><li>beq指令的执行阶段可以分成两个小阶段吗</li></ol><p>beq指令的执行阶段可以分成两个小阶段：执行和分支判断。具体来说：</p><ul><li><p>执行阶段：将第一个操作数和第二个操作数相减，得到运算结果。这个阶段与其他指令的执行阶段类似，不需要特别的处理。</p></li><li><p>分支判断阶段：在执行阶段得到的运算结果为0时，表示两个操作数相等，此时需要跳转。因此，在分支判断阶段，需要判断执行阶段得到的运算结果是否为0，如果是，就需要进行跳转。为了实现这个功能，需要在<strong>执行阶段</strong>将跳转地址保存在流水线寄存器中，并在<strong>分支判断阶段从流水线寄存器中取出跳转地址并判断是否需要跳转</strong>。如果需要跳转，就将取出的跳转地址送到PC（程序计数器）中，更新下一条指令的地址。如果不需要跳转，就继续执行下一条指令。</p></li></ul><ol start="4"><li>EXE2的PPT第19页为什么i5要阻塞一个周期？<br>为了等t0<br>那为什么$t2不需要等WB结束呢？<br>第17页为什么MEM&#x2F;ID是灰色的？</li></ol>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> ACA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
            <tag> ACA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/04/23/leetcode(%E9%93%BE%E8%A1%A8)/"/>
      <url>/2023/04/23/leetcode(%E9%93%BE%E8%A1%A8)/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>&#x2F;**</p><ul><li>Definition for singly-linked list.</li><li>public class ListNode {</li><li><pre><code>int val;</code></pre></li><li><pre><code>ListNode next;</code></pre></li><li><pre><code>ListNode() &#123;&#125;</code></pre></li><li><pre><code>ListNode(int val) &#123; this.val = val; &#125;</code></pre></li><li><pre><code>ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</code></pre></li><li>}<br> *&#x2F;</li></ul><ul><li>链表怎么遍历</li><li>怎么解决位数不同的问题。我好像知道了，从低位开始加。一开始没考虑到位数比较小的数后期指向空指针的问题，可能需要分类讨论。如果l1没空，l2空了，</li></ul><ol><li>链表要用 -&gt;</li><li>链表定义：ListNode *l3&#x3D;l1,*l4&#x3D;l2;</li><li>链表和数组不同，可以在函数体内定义新的指针并返回</li><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        int index=0;</span><br><span class="line">        int sum=0;</span><br><span class="line"></span><br><span class="line">        ListNode *l3=l1,*l4=l2;//遍历指针</span><br><span class="line">        ListNode *l5=l1;//用来存放准备输出的指针</span><br><span class="line"></span><br><span class="line">        while (l3!=NULL &amp;&amp; l4!=NULL) //l3和l4不为空，两数相加，存入l1中</span><br><span class="line">        &#123;</span><br><span class="line">            sum=l3-&gt;val+l4-&gt;val+index;</span><br><span class="line">            index=0;//想加完以后要把index即使设置成0</span><br><span class="line">            if(sum&lt;10) </span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val=sum;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val=sum-10;</span><br><span class="line">                index=1;</span><br><span class="line">            &#125;//这个用取余</span><br><span class="line">            l1=l1-&gt;next;//准备l1的下一个结点赋值</span><br><span class="line">            l3=l3-&gt;next;//遍历l3和l4</span><br><span class="line">            l4=l4-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //到目前为止，肯定有一个链表已经被遍历完了(也就是说，l3或l4==NULL)</span><br><span class="line">        while(l3==NULL&amp;&amp;l4!=NULL)//l4没有遍历完，说明l2比l1长，说明l3和l1被遍历完了，说明我们需要添加新的节点给l3和l1</span><br><span class="line">        &#123; </span><br><span class="line">            sum=l4-&gt;val+index;</span><br><span class="line">            index=0; </span><br><span class="line">                    </span><br><span class="line">            if(sum&lt;10) l1-&gt;val=sum;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val=sum-10;</span><br><span class="line">                index=1;</span><br><span class="line">            &#125; </span><br><span class="line">            ListNode *newNode1=new ListNode();</span><br><span class="line">            l1-&gt;next=l4-&gt;next=newNode1;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l4=l4-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        //到目前为止，l4也被遍历完了，l4==NULL</span><br><span class="line">        while(l3!=NULL&amp;&amp;l4==NULL)//l3没有被遍历完</span><br><span class="line">        &#123;</span><br><span class="line">            sum=l3-&gt;val+index;</span><br><span class="line">            index=0;</span><br><span class="line"></span><br><span class="line">            if(sum&lt;10) </span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val=sum;</span><br><span class="line">                //index=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                l1-&gt;val=sum-10;</span><br><span class="line">                index=1;</span><br><span class="line">            &#125;  </span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l3=l3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        //到目前为止，l3和l4肯定都遍历完了</span><br><span class="line">        if(index)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *newNode2=new ListNode(1);</span><br><span class="line">            l1-&gt;next=newNode2;</span><br><span class="line">        &#125;</span><br><span class="line">        return l5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="chatgpt分析"><a href="#chatgpt分析" class="headerlink" title="chatgpt分析"></a>chatgpt分析</h2><p>这段代码实现的是两个非负整数的链表相加，返回一个新的链表作为结果。代码有以下问题：</p><ol><li>在链表头节点没有值的情况下，需要创建一个新的节点来存储结果，但是代码中没有考虑这种情况。</li></ol><p>我们使用指针 l5 来指向第一个节点，指针 l1 用于遍历链表并修改节点的值。在链表头节点没有值的情况下，我们需要创建一个新的节点，让 l1 指向这个新的节点。这个新的节点就是链表的头节点，其实际上是存储结果的链表。</p><p>具体来说，在这段代码中，我们将 l1 初始化为 l5，即让 l1 指向第一个节点。当我们在循环中修改节点的值时，我们实际上是修改了 l1 所指向节点的值。如果 l1 所指向的节点是链表的头节点，即它没有值，那么我们需要先创建一个新的节点，让 l1 指向这个新的节点。这个新的节点就是存储结果的链表的头节点。这样，我们就可以在链表头节点没有值的情况下，通过创建新的节点来存储结果。</p><ol start="2"><li><p>在两个链表中，一个链表比另一个长的情况下，代码没有考虑添加新节点的情况，也没有正确处理进位。</p></li><li><p>当相加结果超过10的时候，代码使用的是sum-10来计算当前节点的值，但是应该使用sum%10来计算余数。</p></li><li><p>当最高位相加需要进位的时候，代码没有正确处理这种情况。</p></li><li><p>在返回结果之前，代码没有处理新创建的节点的内存释放，容易出现内存泄漏。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 链表(Linked list) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生词本</title>
      <link href="/2023/04/19/new%20words/"/>
      <url>/2023/04/19/new%20words/</url>
      
        <content type="html"><![CDATA[<h1 id="agnostic"><a href="#agnostic" class="headerlink" title="agnostic"></a>agnostic</h1><p>[英] · &#x2F;æɡˈnɒstɪk&#x2F;</p><p>[n.] 不可知论者，不可知论的</p><p>例句：</p><ul><li><p>He was raised in a religious family, but now considers himself an agnostic. (他在一个宗教家庭中长大，但现在认为自己是个不可知论者。)</p></li><li><p>The debate between the atheist and the agnostic became quite heated. (无神论者和不可知论者之间的辩论变得非常激烈。)</p></li><li><p>She has always been curious about different religions, but remains agnostic herself. (她一直对不同的宗教很好奇，但自己仍然是个不可知论者。)</p></li></ul><h1 id="improve-and-squeeze-the-performance"><a href="#improve-and-squeeze-the-performance" class="headerlink" title="improve and squeeze the performance"></a>improve and squeeze the performance</h1><p>“squeeze” 在这个句子中的意思是“挤压”，指通过紧缩或压缩来提高表现。整个句子的意思是“改善并挤压表现”。</p><p>这里的 “squeeze” 可以理解为一种习语，表示尽可能地利用资源或时间来达到最佳效果。类似的英文例句有：</p><ol><li>We need to squeeze every last drop of performance out of our team.</li></ol><p>（我们需要从团队中挤出每一滴性能）</p><ol start="2"><li>The coach is trying to squeeze more speed out of the athlete’s running technique.</li></ol><p>（教练正在试图从运动员跑步技术中挤出更多速度）</p><ol start="3"><li>I’m going to have to squeeze in a workout before my meeting this afternoon.</li></ol><p>（我得在今天下午开会前抽空做一次锻炼）</p><h1 id="go-beyond"><a href="#go-beyond" class="headerlink" title="go beyond"></a>go beyond</h1><p>Go beyond” 在这个句子中是一个动词短语，意思是“超越、突破”。整个句子的意思是“我们如何能够超越现有的限制或者达到更高的目标”。</p><p>举几个相同意思的例句：</p><ol><li><p>We need to go beyond our comfort zone if we want to achieve success.（如果想要成功，我们需要突破自己舒适区）</p></li><li><p>The company is trying to go beyond its competitors by offering better services.（公司正在通过提供更好的服务来超越竞争对手）</p></li><li><p>To truly understand a culture, you must go beyond the surface level and delve deeper into its history and traditions.（要真正理解一种文化，你必须深入了解其历史和传统）</p></li></ol><h1 id="arguerarchy"><a href="#arguerarchy" class="headerlink" title="arguerarchy"></a>arguerarchy</h1><p>[英语] · &#x2F;ˌɑːɡjuˈærki&#x2F;</p><p>[n.] 争论统治，以争辩为基础的领导方式</p><p>例句：</p><ol><li><p>The company’s decision-making process is often slowed down by the arguerarchy among its top executives. (公司的决策过程常常被高管之间的争论所拖延。)</p></li><li><p>Some people believe that democracy is just another form of arguerarchy, where those who are loudest and most persuasive get their way. (有些人认为民主只是另一种形式的争论统治，在这里最响亮和最有说服力的人能够得到他们想要的。)</p></li><li><p>In an arguerarchy, it can be difficult for new ideas or perspectives to gain traction if they don’t fit with the prevailing opinions of those in power. (在一个以争辩为基础的领导方式中，如果新思想或观点与当权者普遍持有的意见不符，它们很难获得支持。)</p></li></ol><h1 id="coarse-grained-multithreading"><a href="#coarse-grained-multithreading" class="headerlink" title="coarse grained multithreading"></a>coarse grained multithreading</h1><p>“coarse”的意思是“粗糙的”或者“粗略的”。整个句子指的是一种多线程技术，其中任务被分成较大、较粗糙的块来执行。</p><p>类似含义的tl例句有：</p><ul><li><p>Fine-grained multithreading（细粒度多线程）</p></li><li><p>Coarse-grained parallelism（粗略并行）</p></li></ul><p>简单解释一下这些例句：Fine-grained multithreading 指将任务划分为更小、更细致的块以实现多线程；Coarse-grained parallelism 则指使用相对较大和不太详细地定义任务来实现并行处理。</p><h1 id="salvation"><a href="#salvation" class="headerlink" title="salvation"></a>salvation</h1><p>[英] &#x2F;sælˈveɪʃən&#x2F;<br>[n.] 拯救，救赎<br>例句：</p><ol><li>The church teaches that salvation comes through faith in Jesus Christ. (教会认为拯救来自于对耶稣基督的信仰。)</li><li>He felt a sense of salvation after confessing his sins to the priest. (向神父忏悔后，他感到一种解脱感。)</li><li>Many people seek salvation from their problems through meditation or prayer. (许多人通过冥想或祷告寻求摆脱问题的拯救。)</li></ol><h1 id="utilization"><a href="#utilization" class="headerlink" title="utilization"></a>utilization</h1><p>[英] · &#x2F;juːtɪlaɪ’zeɪʃ(ə)n&#x2F;</p><p>[n.] 利用，使用</p><p>例句：</p><ol><li><p>The company aims to increase the utilization of its resources. (公司旨在提高其资源的利用率。)</p></li><li><p>Proper utilization of time is essential for success. (合理利用时间对于成功至关重要。)</p></li><li><p>The government is promoting the utilization of renewable energy sources. (政府正在推广可再生能源的利用。)</p></li></ol><h1 id="furious"><a href="#furious" class="headerlink" title="furious"></a>furious</h1><p>[英语] · &#x2F; ˈfjʊəriəs &#x2F;</p><p>[形容词] 狂怒的；暴怒的；猛烈的</p><p>例句：</p><ol><li>She was absolutely furious when she found out.</li></ol><p>（她发现后非常愤怒。）</p><ol start="2"><li>The fans were furious at the team’s performance.</li></ol><p>（球迷对队伍表现感到非常愤怒。）</p><ol start="3"><li>He slammed the door in a furious rage.</li></ol><p>（他勃然大怒，砰地一声关上了门。）</p><h1 id="taxonomy"><a href="#taxonomy" class="headerlink" title="taxonomy"></a>taxonomy</h1><p>[英] &#x2F;tækˈsɒnəmi&#x2F;</p><p>[n.] 分类学</p><p>例句：</p><ol><li><p>The taxonomy of this species is still under debate. (这个物种的分类学仍在争议中。)</p></li><li><p>She specializes in the taxonomy of marine organisms. (她专攻海洋生物的分类学。)</p></li><li><p>Taxonomy is an important field in biology and ecology. (分类学是生物和生态学中重要的领域。)</p></li></ol><h1 id="decrement"><a href="#decrement" class="headerlink" title="decrement"></a>decrement</h1><p>[英] &#x2F;ˈdɛkrɪmənt&#x2F;<br>[n.] 递减，减少<br>[v.] 减少，逐渐变小</p><p>例句：</p><ol><li><p>The company’s profits have been in a state of decrement for the past year. (公司的利润在过去一年里一直处于下降状态。)</p></li><li><p>We need to decrement our expenses if we want to save money. (如果我们想要省钱，就需要减少开支。)</p></li><li><p>The population of this town has been decrementing steadily over the years. (这个城镇的人口数量多年来一直在稳步下降。</p></li></ol><h1 id="elaborate"><a href="#elaborate" class="headerlink" title="elaborate"></a>elaborate</h1><p>[英] &#x2F;ɪˈlæbərət&#x2F;<br>[动词] 详细阐述；精心制作；详尽阐明<br>[形容词] 精心制作的；复杂的<br>例句：</p><ol><li>She elaborated on her plans for the future. (她详细阐述了自己未来的计划。)</li><li>The cake was beautifully elaborate. (这个蛋糕做得非常精美。)</li><li>He gave an elaborate explanation of his theory. (他对自己的理论进行了详尽的解释。)</li></ol><h1 id="chronologically"><a href="#chronologically" class="headerlink" title="chronologically"></a>chronologically</h1><p>[英] · &#x2F;ˌkrɒnəˈlɒdʒɪkli&#x2F;<br>[副词] 按时间顺序地<br>例句：</p><ol><li>The events were presented chronologically in the history book. (这本历史书按照时间顺序呈现了事件。)</li><li>Please arrange the documents chronologically before submitting them. (请在提交前按时间顺序排列文件。)</li><li>The professor explained the development of the theory chronologically during his lecture. (教授在讲座中按照时间顺序解释了理论的发展。)</li></ol><h1 id="ancestor"><a href="#ancestor" class="headerlink" title="ancestor"></a>ancestor</h1><p>[英] &#x2F;ˈæn.ses.tər&#x2F;<br>[n] 祖先，祖宗<br>例句：</p><ol><li>My ancestors came from Ireland. (我的祖先来自爱尔兰。)</li><li>We should respect our ancestors and their traditions. (我们应该尊重我们的祖先和他们的传统。)</li><li>The study of genealogy helps people trace their ancestors and family history. (家谱研究帮助人们追溯他们的祖先和家族历史。)</li></ol><h1 id="ellipse"><a href="#ellipse" class="headerlink" title="ellipse"></a>ellipse</h1><p>[英语] · &#x2F; ɪˈlɪps &#x2F;<br>[n.] 椭圆形<br>例句：</p><ol><li>The planet’s orbit is an ellipse.<br>（这颗行星的轨道是一个椭圆。）</li><li>The shape of the pool was an elongated ellipse.<br>（游泳池的形状是一个细长的椭圆形。）</li><li>She drew an ellipse on the paper to demonstrate its shape.<br>（她在纸上画了一个椭圆来展示它的形状。）</li></ol><h1 id="concatenate"><a href="#concatenate" class="headerlink" title="concatenate"></a>concatenate</h1><p>[英] &#x2F;kən’kætɪneɪt&#x2F;<br>[v] 连接，串联<br>例句：</p><ol><li>You can concatenate two strings using the “+” operator. (你可以使用“+”运算符连接两个字符串。)</li><li>The program will concatenate all the files in the folder into one document. (该程序将把文件夹中的所有文件连接成一个文档。)</li><li>In Excel, you can use the CONCATENATE function to combine text from different cells into one cell. (在Excel中，您可以使用CONCATENATE函数将来自不同单元格的文本组合到一个单元格中。)</li></ol><h1 id="compatible"><a href="#compatible" class="headerlink" title="compatible"></a>compatible</h1><p>[英] &#x2F;kəmˈpætəbl&#x2F;<br>[形] 兼容的；能共存的；和谐相处的<br>例句：</p><ol><li>The software is compatible with both Windows and Mac operating systems. (这个软件可以在Windows和Mac操作系统上运行。)</li><li>Their personalities are very compatible, which makes them great friends. (他们性格非常合得来，所以成为了好朋友。)</li><li>This printer is not compatible with older versions of the software. (这台打印机不兼容旧版本的软件。)</li></ol><h1 id="recast"><a href="#recast" class="headerlink" title="recast"></a>recast</h1><p>[英语] · &#x2F;riːˈkæst&#x2F;<br>[v.] 重新铸造；重塑；改写<br>例句：</p><ol><li>The director recast the lead role with a more experienced actor. (导演用更有经验的演员重新选角了主角。)</li><li>She decided to recast her novel as a screenplay. (她决定将自己的小说改编成剧本。)</li><li>The company had to recast their budget after unexpected expenses arose. (公司不得不在出现意外开支后重新制定预算。)</li></ol><h1 id="motif"><a href="#motif" class="headerlink" title="motif"></a>motif</h1><p>[英] · &#x2F;məʊˈtiːf&#x2F;<br>[n.] 主题；图案；动机<br>例句：</p><ol><li>The motif of the painting is a beautiful sunset over the ocean. (这幅画的主题是海洋上美丽的日落。)</li><li>The fabric has a floral motif that adds a touch of elegance to the dress. (这种面料有花卉图案，为裙子增添了一份优雅。)</li><li>The writer often uses the same motif in his novels, exploring different aspects of it each time. (这位作家经常在他的小说中使用相同的主题，在每次探索不同方面。)</li></ol><h1 id="usualization"><a href="#usualization" class="headerlink" title="usualization"></a>usualization</h1><p>[英] · &#x2F;ˌjuːʒʊəlaɪ’zeɪʃ(ə)n&#x2F;<br>[n.] 通常化，标准化<br>例句：</p><ol><li>The usualization of this process will greatly improve efficiency. (这个过程的标准化将极大地提高效率。)</li><li>Usualization is an important step in quality control. (通常化是质量控制中的重要步骤。)</li><li>The company has implemented a policy of usualization across all departments. (公司已在所有部门实施了通常化政策。)</li></ol><h1 id="divergent"><a href="#divergent" class="headerlink" title="divergent"></a>divergent</h1><p>[英] · &#x2F;daɪˈvɜːdʒənt&#x2F;<br>[形容词] 1. 分歧的；不同的 2. 发散的；分叉的<br>例句：</p><ol><li>The opinions of the two experts are divergent on this issue.<br>（这个问题上，两位专家意见不一。）</li><li>The rays of light are divergent after passing through the lens.<br>（光线通过透镜后会发散。）</li><li>Their paths in life were becoming increasingly divergent.<br>（他们人生道路越来越分岔了。）</li></ol><h1 id="priest"><a href="#priest" class="headerlink" title="priest"></a>priest</h1><p>[英] &#x2F;priːst&#x2F;  美 &#x2F;prist&#x2F;<br>[n] &lt;宗&gt;神父；牧师<br>例句：</p><ol><li>The priest led the congregation in prayer. (神父带领教众祷告。)</li><li>He was ordained as a Catholic priest last year. (他去年被任命为天主教神父。)</li><li>The young couple asked the priest to marry them in the church. (这对年轻夫妇请求牧师在教堂里为他们举行婚礼。)</li></ol>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
          <category> New word </category>
          
          <category> 2023.5.7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STUDY </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIDA问题</title>
      <link href="/2023/04/18/MIDA/"/>
      <url>/2023/04/18/MIDA/</url>
      
        <content type="html"><![CDATA[<h2 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h2><ul><li><p>什么是steady_state output?</p></li><li><p>什么是POLES和ZEROS?</p></li><li><p>γ是什么?</p></li><li><p>什么是predictor?</p></li><li><p>y(t)&#x3D;w(z)e(t)是什么？</p></li><li><p>为什么过去的现在的sample相乘等于0</p></li><li><p>笔记第5页y(t+k|t,s)为什么是stochastic process？</p></li><li><p>为什么prediction error是stochastic process？</p></li><li><p>MA的Variance为什么是平方和？为什么会收敛？</p></li><li><p>笔记第6页为什么y(t+k|t)&#x3D;那个</p></li><li><p>为什么Non-zero mean arma是那样的格式？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> MIDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIDA复习</title>
      <link href="/2023/04/18/MIDA%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/04/18/MIDA%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>到明天下午三点应该能看完，之后就开始每天三个exe。明天开始。<br>DB把concurrency做了<br>.<br>stochastic process<br>相当于扔了一百次色子的实验<br>两个signal等价如果他们是同一个stochastic process的实现<br>怎么描述一个S.P.: 用mean和covariance<br>γ(t1,t2)&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> STUDY </category>
          
          <category> POLIMI </category>
          
          <category> MIDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> POLIMI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导入renren-fast包</title>
      <link href="/2023/04/17/2.%20%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%B7%91%E4%B8%8D%E9%80%9A/"/>
      <url>/2023/04/17/2.%20%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%B7%91%E4%B8%8D%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="第一个error"><a href="#第一个error" class="headerlink" title="第一个error"></a>第一个error</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\JDK\jdk-17\bin\java.exe -XX:TieredStopAtLevel=1 -noverify -Dspring.output.ansi.enabled=always &quot;-javaagent:D:\IntelliJ IDEA 2021.3.1\lib\idea_rt.jar=7270:D:\IntelliJ IDEA 2021.3.1\bin&quot; -Dfile.encoding=UTF-8 com.shinwhy.freemall.coupon.FreemallCouponApplication</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release.</span><br><span class="line">错误: 找不到或无法加载主类 com.shinwhy.freemall.coupon.FreemallCouponApplication</span><br><span class="line">原因: java.lang.ClassNotFoundException: com.shinwhy.freemall.coupon.FreemallCouponApplication</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>##chatgpt回答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这个错误信息包含两个部分：</span><br><span class="line"></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Options -Xverify:none and -noverify were deprecated in JDK 13 and will likely be removed in a future release. 这个警告信息是在运行Java虚拟机时出现的，提示你使用的是已经被弃用的选项。这两个选项-Xverify:none和-noverify在JDK 13中已经被弃用，未来的版本可能会被移除。</span><br><span class="line"></span><br><span class="line">错误: 找不到或无法加载主类 com.shinwhy.freemall.coupon.FreemallCouponApplication 原因: java.lang.ClassNotFoundException: com.shinwhy.freemall.coupon.FreemallCouponApplication。 这个错误是在运行Java应用程序时出现的。它表示Java虚拟机无法找到或加载名为com.shinwhy.freemall.coupon.FreemallCouponApplication的主类。这可能是由于类路径问题或者缺少依赖库等原因导致的。</span><br><span class="line"></span><br><span class="line">针对这个错误，你可以考虑以下几个方面：</span><br><span class="line"></span><br><span class="line">检查类路径是否正确。在运行Java应用程序时，Java虚拟机会按照类路径查找类文件。如果类路径设置不正确，那么Java虚拟机就无法找到对应的类文件。你可以通过检查类路径是否包含了com.shinwhy.freemall.coupon.FreemallCouponApplication类文件的目录或jar包来确认类路径是否正确。</span><br><span class="line"></span><br><span class="line">检查是否缺少依赖库。如果程序依赖于其他的库文件，那么需要将这些库文件加入到类路径中，否则Java虚拟机也无法找到对应的类文件。你可以检查应用程序的依赖库，确保依赖库已经正确安装，并且类路径中包含了这些依赖库。</span><br><span class="line"></span><br><span class="line">如果问题仍然存在，你可以尝试使用其他版本的Java虚拟机来运行程序，或者更新程序的依赖库版本。同时，你可以考虑升级到最新版本的JDK，以避免使用已经被弃用的选项。</span><br></pre></td></tr></table></figure><p>第一个问题我尝试装JDK8试试看能不能解决<br>今天突然想到去查一下renren-fast对应的JDK版本，官网上说只支持JDK8，所以我安装JDK8，并修改所有pom.xml文件，好像解决了。<br>##一些小error:</p><blockquote><p><code>找不到符号：.allowedOriginPatterns(&quot;*&quot;)</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/little___ant/article/details/126885567</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>找不到符号：&lt;fork&gt;true&lt;/fork&gt;</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我遇到了几乎同样的问题。</span><br><span class="line"></span><br><span class="line">我使用的是 jdk 16、maven 编译器 3.8.1 和 IntelliJ 版本 2021.1.3。</span><br><span class="line"></span><br><span class="line">对 pom.xml 进行任何更改后，右侧会显示一个小图标（Load Maven Changes）。单击该按钮后，问题就解决了。</span><br></pre></td></tr></table></figure><hr><blockquote><p><code>Error:(3, 29) java: 程序包org.junit.jupiter.api不存在</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/littlehaes/article/details/104088317</span><br></pre></td></tr></table></figure><blockquote><p><code>&#39;parent.relativePath&#39; of POM com.qianbao:hermes_account_service:1.0.0-SNAPSHOT (/Users/wangyonglin/company/blyl/codes/codespackage_foruse/hermes_account_service_v1/pom.xml) points at com.qianbao:hermes_account_service instead of org.springframework.boot:spring-boot-starter-parent, please verify your project structure</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/453547775</span><br></pre></td></tr></table></figure><h1 id="第二个error"><a href="#第二个error" class="headerlink" title="第二个error"></a>第二个error</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Web server failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#x27;s listening on port 8080 or configure this application to listen on another port.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>第二个问题我给每个文件夹配置了不同的端口，暂时解决了<br>后来又尝试了另一种做法，结束占用8080端口的任务，也解决了，占用8080端口的是tomcat<br><code>https://blog.csdn.net/Coder_ljw/article/details/129332755</code></p><p>第一个问题好像是因为tomcat版本不对，我重新配置了tomcat，但目前端口不对，我先试一下改端口号，改端口号不行，仍然显示同样的错误。<br>我在StackOverflow上提交了问题，希望有用，没等到回答</p><blockquote><p>重新下载renren-fast并导入，跟着视频一步步做，终于解决了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Freemall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Freemall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pictr</title>
      <link href="/2023/04/14/pictr/"/>
      <url>/2023/04/14/pictr/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.wallpapermaiden.com/image/2023/01/08/red-eyes-wink-pointy-ears-vampire-crescent-wings-anime-girl-anime-53264.jpeg" alt="图片加载失败" title="壁纸"></p><p><img src="https://www.google.com/imgres?imgurl=https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Everest_North_Face_toward_Base_Camp_Tibet_Luca_Galuzzi_2006.jpg/270px-Everest_North_Face_toward_Base_Camp_Tibet_Luca_Galuzzi_2006.jpg&tbnid=tiz4kC8bF4l3LM&vet=12ahUKEwjR-YOszqn-AhWA8rsIHT1oAwAQMygAegUIARC-AQ..i&imgrefurl=https://zh.wikipedia.org/wiki/%25E7%258F%25A0%25E7%25A9%2586%25E6%259C%2597%25E7%2591%25AA%25E5%25B3%25B0&docid=H7j-p9vjqtKRLM&w=270&h=180&q=%E7%8F%A0%E7%A9%86%E6%9C%97%E7%8E%9B%E5%B3%B0&ved=2ahUKEwjR-YOszqn-AhWA8rsIHT1oAwAQMygAegUIARC-AQ" alt="图片加载失败" title="壁纸"></p><img decoding="async" src="https://s1.wallpapermaiden.com/image/2023/01/08/medicine-melancholy-touhou-lying-down-red-eyes-doll-anime-53262.jpeg" width="20%"><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="/pictr/medicine-melancholy-touhou-lying-down-red-eyes-doll-anime-53262.jpeg" alt="图片加载失败"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="/source/_posts/pictr/futuristic-city-industrial-skyscrapers-sci-fi-53198.jpeg" alt="图片加载失败"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="/./pictr/medicine-melancholy-touhou-lying-down-red-eyes-doll-anime-53262.jpeg" alt="图片加载失败"></p><p><img src="https://t7.baidu.com/it/u=2168645659,3174029352&fm=193&f=GIF" alt="RUNOOB 图标"></p><p><img src="https://cdn.mos.cms.futurecdn.net/NddgAz7AfjNsbsPiM72Ek6-1600-80.jpg.webp" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="https://s1.wallpapermaiden.com/image/2023/01/01/demon-cityscape-wings-mountains-fantasy-53158-resized.jpeg" alt="RUNOOB 图标"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><p><a href="https://cdn.pixabay.com/photo/2018/01/14/23/12/nature-3082832_1280.jpg">https://cdn.pixabay.com/photo/2018/01/14/23/12/nature-3082832_1280.jpg</a></p><p><img src="https://cdn.pixabay.com/photo/2018/01/14/23/12/nature-3082832_1280.jpg" alt="pipi"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大功告成</title>
      <link href="/2023/04/14/%E5%A4%A7%E5%8A%9F%E5%91%8A%E6%88%90/"/>
      <url>/2023/04/14/%E5%A4%A7%E5%8A%9F%E5%91%8A%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>《渡荆门送别》</p><p>渡远荆门外，来从楚国游。山随平野尽，江入大荒流。月下飞天镜，云生结海楼。仍怜故乡水，万里送行舟。渡远荆门外，来从楚国游。山随平野尽，江入大荒流。月下飞天镜，云生结海楼。仍怜故乡水，万里送行舟。</p><p>渡远荆门外，来从楚国游。山随平野尽，江入大荒流。<br>月下飞天镜，云生结海楼。仍怜故乡水，万里送行舟。渡远荆门外，来从楚国游。山随平野尽，江入大荒流。月下飞天镜，云生结海楼。仍怜故乡水，万里送行舟。</p><p>山随平野尽，江入大荒流。</p><p>月下飞天镜，云生结海楼。</p><p>仍怜故乡水，万里送行舟。</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p></blockquote><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p></blockquote><blockquote><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Person()//对象销毁前，自动调用</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">//创建对象</span><br><span class="line">Person  p;//这是一个局部变量，test执行完毕后会释放该对象 进而调用析构函数</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Person  p1;//如果在main函数创建对象，析构函数会在按任意键后再调用</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hello</code></p><p><code>he</code></p><p><img src="https://s1.wallpapermaiden.com/image/2023/01/08/red-eyes-wink-pointy-ears-vampire-crescent-wings-anime-girl-anime-53264.jpeg" alt="图片加载失败" title="壁纸"></p><p><img src="https://www.google.com/imgres?imgurl=https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Everest_North_Face_toward_Base_Camp_Tibet_Luca_Galuzzi_2006.jpg/270px-Everest_North_Face_toward_Base_Camp_Tibet_Luca_Galuzzi_2006.jpg&tbnid=tiz4kC8bF4l3LM&vet=12ahUKEwjR-YOszqn-AhWA8rsIHT1oAwAQMygAegUIARC-AQ..i&imgrefurl=https://zh.wikipedia.org/wiki/%25E7%258F%25A0%25E7%25A9%2586%25E6%259C%2597%25E7%2591%25AA%25E5%25B3%25B0&docid=H7j-p9vjqtKRLM&w=270&h=180&q=%E7%8F%A0%E7%A9%86%E6%9C%97%E7%8E%9B%E5%B3%B0&ved=2ahUKEwjR-YOszqn-AhWA8rsIHT1oAwAQMygAegUIARC-AQ" alt="图片加载失败" title="壁纸"></p><img decoding="async" src="https://s1.wallpapermaiden.com/image/2023/01/08/medicine-melancholy-touhou-lying-down-red-eyes-doll-anime-53262.jpeg" width="20%">]]></content>
      
      
      <categories>
          
          <category> 2019 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2013 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/14/hello-world/"/>
      <url>/2023/04/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装</title>
      <link href="/2023/04/14/Docker%E5%AE%89%E8%A3%85/"/>
      <url>/2023/04/14/Docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>#Docker容器文件挂载和端口映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br><span class="line">参数说明</span><br><span class="line">-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂载到主机</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql/：将配置文件夹挂载到主机-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码</span><br></pre></td></tr></table></figure><p>这里有报错，使用<code>docker logs -f &lt;container ID&gt;</code>查看日志，发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2023-04-15 13:31:09+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.41-1.el7 started.</span><br><span class="line">2023-04-15 13:31:09+00:00 [ERROR] [Entrypoint]: mysqld failed while attempting to check config</span><br><span class="line">command was: mysqld --verbose --help --log-bin-index=/tmp/tmp.F82QFTNxFF</span><br><span class="line">mysqld: Can&#x27;t read dir of &#x27;/etc/mysql/conf.d/&#x27; (Errcode: 2 - No such file or directory)</span><br><span class="line">mysqld: [ERROR] Fatal error in defaults handling. Program aborted!</span><br></pre></td></tr></table></figure><p>修改配置文件的docker容器目录解决问题解决问题</p><p><strong>容器和容器之间相互隔离，相当于一个独立的运行环境</strong></p><p>访问容器内部：<br><code>docker exec -it mysql /bin/bash</code><br>这里还有另一种直接进入的方法<br><code>docker exec -it redis redis-cli</code><br>查看运行的容器<br><code>docker ps</code></p><p>1.查看所有运行中的容器 <code>docker ps</code>；<br>2.停止容器运行 <code>docker stop &lt;container-id&gt;</code>；<br>3.删除这个容器 <code>docker rm &lt;container-id&gt;</code>；<br>4.删除这个镜像 <code>docker rmi &lt;image-id&gt;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Freemall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Freemall </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
